<!doctype html>
<meta charset="utf-8" />
<style>
  :root {
    --bg: #fff;
    --muted: #f5f5f7;
    --line: #e6e6e6;
    --primary: #7f56d9;
    --text: #111827;
    --subtle: #6b7280;
  }
  *,
  *::before,
  *::after {
    box-sizing: border-box;
  }
  html,
  body {
    font: 14px/1.4 "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
    margin: 0;
    width: 100%;
    max-width: 100%;
    background: var(--bg);
    color: var(--text);
    overflow-x: hidden;
    overflow-y: hidden;
    min-height: 100%;
    height: 100%;
  }
  .tab-bar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
    margin: 12px 16px 4px;
  }
  .tabs {
    display: inline-flex;
    align-items: center;
    gap: 0;
    margin: 0;
    border-radius: 12px;
    background: #f5f5f5;
    padding: 0;
  }
  .tab {
    margin: 0;
    padding: 12px;
    cursor: pointer;
    user-select: none;
    font-family: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
    font-weight: 400;
    font-size: 14px;
    line-height: 20px;
    color: #94a3b8;
    background: #f5f5f5;
    border-radius: 12px;
    transition: color 0.15s ease, background 0.15s ease;
  }
  .tab.active {
    color: #00b0ff;
    font-weight: 500;
    background: #e6f8ff;
  }
  .tab-actions {
    display: flex;
    align-items: center;
    gap: 4px;
  }
  .tab-action {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 12px;
    border-radius: 12px;
    border: 1px solid #f5f5f5;
    background: #fff;
    color: #94a3b8;
    font-weight: 400;
    font-size: 14px;
    line-height: 20px;
    font-family: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
    cursor: pointer;
  }
  .tab-action.length-toggle.active,
  .tab-action.keyword-toggle.active {
    border-color: #00b0ff;
    color: #0f172a;
    box-shadow: 0 0 0 1px rgba(0, 176, 255, 0.25);
  }
  .tab-action.length-toggle.has-selection,
  .tab-action.keyword-toggle.has-selection {
    background: rgba(0, 176, 255, 0.1);
    border-color: transparent;
    box-shadow: none;
    color: #0f172a;
  }
  .tab-action:focus-visible {
    outline: 2px solid #00b0ff;
    outline-offset: 2px;
  }
  .tab-action.has-selection:focus-visible,
  .tab-action.active:focus-visible {
    outline: none;
  }
  .tab-action-icon {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 0;
  }
  .tab-action-icon svg,
  .tab-action-icon img {
    width: 16px;
    height: 16px;
    display: block;
  }
  .length-toggle .length-icon {
    display: none;
  }
  .length-toggle:not(.has-selection) .length-icon--dropdown,
  .length-toggle.has-selection .length-icon--remove {
    display: block;
  }
  .keyword-toggle .keyword-icon {
    display: none;
  }
  .keyword-toggle:not(.has-selection) .keyword-icon--plus,
  .keyword-toggle.has-selection .keyword-icon--remove {
    display: block;
  }
  .keyword-dropdown {
    position: relative;
  }
  .keyword-menu {
    position: absolute;
    top: calc(100% + 6px);
    right: 0;
    width: 280px;
    background: #fff;
    border: 1px solid #e5e7eb;
    border-radius: 12px;
    box-shadow: 0 24px 40px rgba(15, 23, 42, 0.15);
    padding: 14px;
    display: none;
    flex-direction: column;
    gap: 12px;
    z-index: 12;
    max-height: 228px;
    overflow-y: auto;
    scrollbar-color: #eceef1 transparent;
    scrollbar-width: thin;
    box-sizing: border-box;
    padding-right: 20px;
  }
  .keyword-menu::-webkit-scrollbar {
    width: 8px;
  }
  .keyword-menu::-webkit-scrollbar-track {
    background: transparent;
  }
  .keyword-menu::-webkit-scrollbar-thumb {
    background: #eceef1;
    border-radius: 999px;
  }
  .keyword-menu.visible {
    display: flex;
  }
  .keyword-menu-card {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }
  .keyword-menu .keyword-label-row {
    justify-content: flex-start;
  }
  .keyword-menu .keyword-label-row label {
    color: #788494;
    font-family: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
    font-size: 10px;
    font-style: normal;
    font-weight: 700;
    line-height: 16px;
    letter-spacing: 1px;
    text-transform: uppercase;
  }
  .keyword-menu .chip-input {
    border-color: #e0e7ff;
    background: transparent;
    padding: 8px;
  }
  .keyword-menu .chip-input:focus-within {
    border-color: #00b0ff;
    box-shadow: 0 0 0 1px rgba(0, 176, 255, 0.25);
  }
  .length-dropdown {
    position: relative;
  }
  .length-toggle-text {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    line-height: 1.2;
  }
  .keyword-toggle span {
    display: inline-flex;
    flex-direction: column;
    line-height: 1.2;
    font-weight: 400;
    color: inherit;
    transition: color 0.2s ease;
  }
  .length-toggle-title {
    font-weight: 400;
    font-size: 14px;
    color: #94a3b8;
  }
  .tab-action.length-toggle.has-selection .length-toggle-title,
  .tab-action.length-toggle.active .length-toggle-title {
    color: #00b0ff;
    font-weight: 500;
  }
  .tab-action.keyword-toggle.has-selection span {
    color: #00b0ff;
    font-weight: 500;
  }
  .length-toggle-selection {
    display: none;
    align-items: center;
    gap: 6px;
    margin-left: 12px;
    padding: 4px 10px;
    border-radius: 999px;
    position: relative;
    background: rgba(0, 176, 255, 0.1);
    color: #00b0ff;
    font-size: 13px;
    font-weight: 500;
  }
  .tab-action.length-toggle.has-selection .length-toggle-selection {
    gap: 0;
    display: none;
  }
  .length-toggle-selection.visible {
    display: inline-flex;
  }
  .length-toggle-selection-remove {
    width: 16px;
    height: 16px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
  }
  .length-toggle-selection-remove img {
    width: 16px;
    height: 16px;
    display: block;
  }
  .tab-action.length-toggle.has-selection .length-toggle-selection-label {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    border: 0;
    clip: rect(0 0 0 0);
    clip-path: inset(50%);
    overflow: hidden;
    white-space: nowrap;
  }
  .length-menu {
    position: absolute;
    top: calc(100% + 4px);
    right: 0;
    width: 140px;
    background: #fff;
    border: 1px solid #E2E8F0;
    border-radius: 12px;
    box-shadow: 0 20px 40px rgba(15, 23, 42, 0.12);
    padding: 0;
    display: none;
    flex-direction: column;
    z-index: 10;
    overflow: hidden;
    box-sizing: border-box;
  }
  .length-menu.visible {
    display: flex;
  }
  .length-menu-list {
    display: flex;
    flex-direction: column;
    max-height: 260px;
    overflow-y: auto;
    padding-right: 8px;
  }
  .length-option {
    width: calc(100% + 8px);
    margin-right: -8px;
    box-sizing: border-box;
    border: none;
    background: transparent;
    border-radius: 10px;
    padding: 8px 16px;
    cursor: pointer;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 4px;
    align-self: stretch;
    font-family: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
    color: #000;
    font-size: 14px;
    font-style: normal;
    font-weight: 400;
    line-height: 17px;
  }
  .length-option:hover,
  .length-option:focus-visible,
  .length-option.selected:hover {
    outline: none;
    background: #ebf9ff;
    border-radius: 0;
  }
  .length-option.selected {
    color: #00b0ff;
    font-weight: 500;
    background: transparent;
  }
  .panel {
    padding: 0 16px 16px;
    display: none;
    height: calc(100% - 56px);
    overflow: hidden;
    flex-direction: column;
  }
  .panel.active {
    display: flex;
  }
  .rewrite-screen {
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.25s ease;
    pointer-events: none;
    height: 100%;
    display: flex;
    flex-direction: column;
  }
  .rewrite-screen.active {
    opacity: 1;
    visibility: visible;
    pointer-events: auto;
  }
  .rewrite-screen[hidden] {
    display: none !important;
  }
  .rewrite-screen.loading-screen {
    display: flex;
  }
  .rewrite-screen-container {
    height: 100%;
  }
  .loading-screen {
    min-height: 320px;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 16px;
    text-align: center;
    padding: 32px 16px;
  }
  .loading-screen p {
    margin: 0;
    font-size: 16px;
    line-height: 22px;
    color: #111827;
    font-weight: 500;
    white-space: pre-line;
  }
  .loading-illustration {
    width: 112px;
    height: 112px;
    border-radius: 50%;
    background: #e3f2ff;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .loading-illustration svg {
    width: 90px;
    height: 90px;
    display: block;
  }
  .back-button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    border: none;
    background: transparent;
    cursor: pointer;
    padding: 4px;
    border-radius: 999px;
  }
  .back-button svg {
    width: 24px;
    height: 24px;
    display: block;
  }
  .back-button:focus-visible {
    outline: 2px solid #7f56d9;
    outline-offset: 2px;
  }
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    border: 0;
  }
  .suggestions-screen {
    padding: 16px 0 16px;
  }
  .field-header {
    display: none;
    padding-left: 12px;
  }
  .field-label {
    color: #525b65;
    font-size: 14px;
    line-height: 20px;
    font-weight: 500;
  }
  /* shared input styles */
  textarea,
  input[type="text"] {
    width: 100%;
    padding: 12px;
    border: 1px solid #f5f5f5;
    border-radius: 4px;
    font-family: inherit;
    font-size: 14px;
    box-sizing: border-box;
    transition: border-color 0.15s ease;
  }
  textarea {
    resize: none;
    min-height: 52px;
    overflow-y: hidden;
    margin: 0;
  }
  textarea::placeholder,
  input[type="text"]::placeholder {
    color: #788494;
    line-height: 20px;
  }
  textarea:focus,
  input[type="text"]:focus {
    border-color: #00b0ff;
    outline: none;
  }
  .guideline-status {
    margin: 8px 0 0;
    font-size: 12px;
    color: var(--subtle);
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .guideline-status .status-dot {
    width: 8px;
    height: 8px;
    border-radius: 999px;
    background: #d1d5db;
  }
  .guideline-status.loaded .status-dot {
    background: #34d399;
  }
  .guideline-status.fallback .status-dot {
    background: #fbbf24;
  }
  .guideline-status.error .status-dot {
    background: #f87171;
  }
  .copy-field {
    position: relative;
    flex: 1;
    background: #fff;
    border-radius: 12px 12px 0 0;
    border: 1px solid #F5F5F5;
    border-bottom: none;
    padding: 0px;
    display: flex;
    flex-direction: column;
    margin-top: 8px;
    overflow: hidden;
  }
  .copy-field textarea {
    flex: 1;
    border: none;
    padding: 12px;
    font-size: 14px;
    line-height: 17px;
    color: #0f172a;
    background: transparent;
    resize: none;
    min-height: 0;
    margin: 0;
    padding-right: 12px;
    padding-bottom: 12px;
    max-height: 300px;
    overflow-y: auto;
    width: calc(100% + 12px);
    box-sizing: border-box;
    margin-right: -12px;
    scrollbar-color: #eceef1 transparent;
    scrollbar-width: thin;
  }
  .copy-field textarea::-webkit-scrollbar {
    width: 8px;
  }
  .copy-field textarea::-webkit-scrollbar-track {
    background: transparent;
  }
  .copy-field textarea::-webkit-scrollbar-thumb {
    background: #eceef1;
    border-radius: 999px;
  }
  .copy-field textarea::placeholder {
    color: #94a3b8;
    font-size: 14px;
    line-height: 17px;
  }
  .copy-field textarea:focus {
    outline: none;
  }
  .copy-field::after {
    content: "";
    position: absolute;
    left: 12px;
    right: 12px;
    bottom: 0;
    height: 48px;
    background: linear-gradient(180deg, rgba(255, 255, 255, 0) 0%, #fff 85%);
    pointer-events: none;
  }
  .rewrite-footer {
    background: #fff;
    border: 1px solid #e3e8f2;
    border-top: none;
    border-radius: 0 0 12px 12px;
    padding: 12px;
    display: flex;
    justify-content: space-between;
    gap: 8px;
    align-items: center;
  }
  .rewrite-footer .rewrite-btn {
    width: auto;
    margin: 0;
    padding: 12px 28px;
  }
  .rewrite-icon {
    width: 24px;
    height: 24px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    object-fit: contain;
  }
  .guideline-icon {
    display: none;
  }
  .guideline-icon--enabled {
    display: block;
  }
  body.guideline-fallback .guideline-icon--enabled,
  body.guideline-error .guideline-icon--enabled {
    display: none;
  }
  body.guideline-fallback .guideline-icon--disabled,
  body.guideline-error .guideline-icon--disabled {
    display: block;
  }
  .rewrite-btn {
    width: 100%;
    margin-top: 16px;
    padding: 12px;
    border: 0;
    border-radius: 12px;
    background: #00b0ff;
    color: #fff;
    font-weight: 600;
    font-size: 14px;
    line-height: 17px;
    letter-spacing: 1px;
    text-transform: uppercase;
    cursor: pointer;
    text-align: center;
    position: relative;
    overflow: hidden;
  }
  .rewrite-btn.secondary.hidden {
    display: none;
  }
  .rewrite-btn:disabled:not(.is-loading) {
    cursor: default;
    opacity: 0.65;
  }
  .rewrite-label,
  .rewrite-shimmer {
    display: block;
    transition: opacity 0.2s ease;
  }
  .rewrite-shimmer {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: linear-gradient(110deg, rgba(255,255,255,0.4), #fff, rgba(255,255,255,0.4));
    background-size: 200% auto;
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    animation: shimmerText 1.4s linear infinite;
    font-weight: 700;
    letter-spacing: 0.08em;
    opacity: 0;
    pointer-events: none;
  }
  .rewrite-btn.is-loading .rewrite-label {
    opacity: 0;
  }
  .rewrite-btn.is-loading .rewrite-shimmer {
    opacity: 1;
  }
  @keyframes shimmerText {
    0% {
      background-position: -100% 0;
    }
    100% {
      background-position: 200% 0;
    }
  }
  .suggestions {
    margin-top: 8px;
    border: 0;
    padding: 0 0 16px;
    flex: 1;
    overflow-y: auto;
  }
  .suggestion-body {
    min-height: auto;
    padding: 0;
    color: var(--subtle);
    display: flex;
    flex-direction: column;
    gap: 12px;
  }
  .suggestion-note {
    border-radius: 12px;
    border: 1px solid #fde1c3;
    background: #fff8f1;
    color: #9a3412;
    font-size: 13px;
    line-height: 18px;
    padding: 12px 12px;
  }
  .suggestion-body.centered {
    padding: 16px;
    min-height: 140px;
    justify-content: center;
    align-items: center;
    text-align: center;
    border-radius: 12px;
    background: var(--muted);
  }
  .suggestion-body.error {
    background: #fef2f2;
    color: #991b1b;
    border: 1px solid #fecaca;
  }
  .suggestion-body.centered .empty-arrow {
    font-size: 30px;
    color: #d1d5db;
  }
  .suggestions-list {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    gap: 12px;
  }
  .suggestion-card {
    border-radius: 12px;
    border: 1px solid #f5f5f5;
    background: #ffffff00;
    padding: 12px 14px;
    display: flex;
    flex-direction: column;
    gap: 12px;
    color: #1f2933;
    transition: opacity 0.3s ease, transform 0.3s ease;
    cursor: default;
    height: 100%;
    justify-content: space-between;
  }
  .suggestion-card p {
    margin: 0;
    font-size: 14px;
    flex: 1;
  }
  .suggestion-meta {
    display: flex;
    align-items: flex-end;
    gap: 4px;
    align-self: stretch;
    color: #788494;
    font-family: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
    font-size: 14px;
    font-style: normal;
    font-weight: 400;
    line-height: 20px;
  }
  .suggestion-card.is-interactive {
    cursor: pointer;
  }
  .suggestion-card.is-interactive:focus-visible {
    outline: 2px solid #00b0ff;
    outline-offset: 2px;
  }
  .suggestion-card.is-interactive:active {
    transform: translateY(1px);
  }
  .suggestions-list.is-loading .suggestion-card {
    opacity: 1;
  }
  .suggestion-card.skeleton {
    position: relative;
    overflow: hidden;
    height: 100%;
    justify-content: space-between;
  }
  .suggestion-card.revealing {
    opacity: 0;
    transform: translateY(8px);
  }
  .suggestion-card.revealed {
    opacity: 1;
    transform: translateY(0);
  }
  .skeleton-block {
    background: #e0e0e0;
    position: relative;
    overflow: hidden;
    display: block;
  }
  .skeleton-block::before {
    content: "";
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(
      90deg,
      transparent 0%,
      rgba(255, 255, 255, 0.6) 50%,
      transparent 100%
    );
    animation: shimmer 1.5s infinite;
  }
  @keyframes shimmer {
    0% {
      left: -100%;
    }
    100% {
      left: 100%;
    }
  }
  .skeleton-line,
  .skeleton-pill {
    display: block;
    width: 100%;
    border-radius: 999px;
  }
  .skeleton-line {
    height: 12px;
    margin-bottom: 8px;
  }
  .skeleton-line.long {
    width: 90%;
  }
  .skeleton-line.short {
    width: 55%;
  }
  .skeleton-pill {
    height: 10px;
    width: 72px;
  }
  .skeleton-pill.short {
    width: 42px;
  }
  .skeleton-meta {
    display: flex;
    gap: 8px;
    align-items: center;
    margin-top: 6px;
  }
  @media (prefers-reduced-motion: reduce) {
    .skeleton-block::before {
      animation: none;
    }
  }
  .score-pill {
    background: #d1fae5;
    color: #0f5132;
    border-radius: 6px;
    padding: 2px 8px;
    font-weight: 600;
    font-size: 12px;
  }
  .row {
    display: flex;
    gap: 8px;
    align-items: center;
  }
  .status-text {
    margin-top: 8px;
    font-size: 12px;
    color: var(--subtle);
  }
  .muted-text {
    font-size: 12px;
    color: var(--subtle);
  }
  .length-row {
    margin-top: 16px;
    display: flex;
    flex-direction: column;
    gap: 6px;
  }
  .length-label-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
  }
  .length-label-row label {
    font-size: 14px;
    line-height: 20px;
    font-weight: 500;
    color: #525b65;
  }
  .length-range {
    font-size: 12px;
    color: #94a3b8;
  }
  .length-select {
    width: 100%;
    border: 1px solid #f5f5f5;
    border-radius: 6px;
    padding: 10px 12px;
    font-size: 14px;
    font-family: inherit;
    background: #fff;
    color: #1f2933;
  }
  .length-hint {
    margin: 0;
    font-size: 12px;
    color: #94a3b8;
    line-height: 18px;
  }
  .keyword-section {
    margin-top: 20px;
    display: flex;
    flex-direction: column;
    gap: 16px;
  }
  .keyword-field label {
    display: block;
    font-size: 14px;
    line-height: 20px;
    font-weight: 500;
    color: #525b65;
  }
  .keyword-label-row {
    display: flex;
    align-items: baseline;
    justify-content: space-between;
    gap: 8px;
    margin-bottom: 6px;
  }
  .keyword-hint {
    font-size: 12px;
    color: #94a3b8;
    margin: 0;
  }
  .chip-input {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    padding: 8px;
    border-radius: 8px;
    border: 1px solid #f5f5f5;
    background: #fff;
    min-height: 48px;
  }
  .chip-list {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin-top: 8px;
  }
  .chip-input input {
    border: none;
    flex: 1 1 140px;
    min-width: 120px;
    font-size: 14px;
    padding: 6px 4px;
    font-family: inherit;
    color: #1f2933;
  }
  .chip-input input:focus {
    outline: none;
  }
  .keyword-chip {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    border-radius: 12px;
    font-size: 13px;
    line-height: 18px;
    padding: 8px;
  }
  .keyword-chip.include-chip {
    background: rgba(0, 176, 255, 0.1);
    color: #00b0ff;
  }
  .keyword-chip.avoid-chip {
    background: rgba(244, 67, 54, 0.1);
    color: #f44336;
  }
  .keyword-chip button {
    border: none;
    background: transparent;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 16px;
    height: 16px;
    padding: 0;
    cursor: pointer;
  }
  .keyword-chip button img {
    width: 16px;
    height: 16px;
    display: block;
  }
  .keyword-chip button:focus-visible {
    outline: 2px solid #00b0ff;
    outline-offset: 2px;
  }
  .chip-list {
    max-height: 160px;
    overflow-y: auto;
    scrollbar-color: #eceef1 transparent;
    scrollbar-width: thin;
  }
  .chip-list::-webkit-scrollbar {
    width: 8px;
  }
  .chip-list::-webkit-scrollbar-track {
    background: transparent;
  }
  .chip-list::-webkit-scrollbar-thumb {
    background: #eceef1;
    border-radius: 999px;
  }
  .char-counter {
    font-size: 12px;
    line-height: 18px;
    color: #788494;
  }
</style>

<div class="tab-bar">
  <div class="tabs">
    <div id="tab-rewrite" class="tab active">Rewrite</div>
    <div id="tab-suggestions" class="tab">Suggestions</div>
    <div id="tab-settings" class="tab">Settings</div>
  </div>
  <div class="tab-actions">
    <div class="length-dropdown">
      <button
        type="button"
        id="lengthToggle"
        class="tab-action length-toggle"
        aria-haspopup="true"
        aria-expanded="false"
      >
      <span class="length-toggle-text">
        <span class="length-toggle-title">Length</span>
      </span>
      <span class="length-toggle-selection" data-length-selection>
        <span class="length-toggle-selection-label"></span>
        <span class="length-toggle-selection-remove" role="button" tabindex="0" aria-label="Clear length selection">
          <img src="Icons/Remove.svg" alt="" aria-hidden="true" />
        </span>
      </span>
        <span class="tab-action-icon" aria-hidden="true">
          <svg class="length-icon length-icon--dropdown" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg">
            <path d="M0 8C0 12.4183 3.58172 16 8 16C12.4183 16 16 12.4183 16 8C16 3.58172 12.4183 0 8 0C3.58172 0 0 3.58172 0 8Z" fill="#00B0FF" />
            <path d="M9.62024 5.94997C10.0665 5.50366 10.7902 5.50366 11.2365 5.94997C11.6828 6.39628 11.6828 7.1199 11.2365 7.56621L8.71104 10.0917C8.32051 10.4822 7.68735 10.4822 7.29682 10.0917L4.7715 7.56633C4.32519 7.12002 4.32519 6.3964 4.7715 5.95009C5.21782 5.50378 5.94143 5.50378 6.38775 5.95009L8.00393 7.56627L9.62024 5.94997Z" fill="white" />
          </svg>
          <svg class="length-icon length-icon--remove" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg">
            <path d="M0 8C0 12.4183 3.58172 16 8 16C12.4183 16 16 12.4183 16 8C16 3.58172 12.4183 0 8 0C3.58172 0 0 3.58172 0 8Z" fill="#00B0FF" />
            <path d="M9.62055 11.2326C10.0669 11.6789 10.7905 11.6789 11.2368 11.2326C11.6831 10.7863 11.6831 10.0627 11.2368 9.61636L9.62049 8.00005L11.2368 6.38375C11.6831 5.93744 11.6831 5.21382 11.2368 4.7675C10.7905 4.32119 10.0669 4.32119 9.62055 4.7675L8.00425 6.38381L6.38807 4.76763C5.94175 4.32131 5.21814 4.32131 4.77182 4.76763C4.32551 5.21394 4.32551 5.93756 4.77182 6.38387L6.38801 8.00005L4.77182 9.61624C4.32551 10.0626 4.32551 10.7862 4.77182 11.2325C5.21814 11.6788 5.94175 11.6788 6.38807 11.2325L8.00425 9.6163L9.62055 11.2326Z" fill="white" />
          </svg>
        </span>
      </button>
      <div id="lengthMenu" class="length-menu" role="menu" aria-hidden="true">
      <div id="lengthMenuList" class="length-menu-list" role="none"></div>
      </div>
    </div>
    <div class="keyword-dropdown">
      <button
        type="button"
        id="keywordToggle"
        class="tab-action keyword-toggle"
        aria-haspopup="true"
        aria-expanded="false"
      >
        <span>Keywords</span>
        <span class="tab-action-icon" aria-hidden="true">
          <svg class="keyword-icon keyword-icon--plus" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg">
            <path d="M8 16C12.4183 16 16 12.4183 16 8C16 3.58172 12.4183 0 8 0C3.58172 0 0 3.58172 0 8C0 12.4183 3.58172 16 8 16Z" fill="#00B0FF"/>
            <path d="M11.4287 9.13869C12.0599 9.13869 12.5716 8.62701 12.5716 7.99583C12.5716 7.36465 12.0599 6.85297 11.4287 6.85297L9.14291 6.85297V4.56717C9.14291 3.93599 8.63124 3.42432 8.00005 3.42432C7.36887 3.42432 6.8572 3.93599 6.8572 4.56717V6.85297H4.57157C3.94039 6.85297 3.42871 7.36465 3.42871 7.99583C3.42871 8.62701 3.94039 9.13869 4.57157 9.13869H6.8572V11.4243C6.8572 12.0555 7.36887 12.5672 8.00005 12.5672C8.63124 12.5672 9.14291 12.0555 9.14291 11.4243V9.13869H11.4287Z" fill="white"/>
          </svg>
          <svg class="keyword-icon keyword-icon--remove" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg">
            <path d="M0 8C0 12.4183 3.58172 16 8 16C12.4183 16 16 12.4183 16 8C16 3.58172 12.4183 0 8 0C3.58172 0 0 3.58172 0 8Z" fill="#00B0FF"/>
            <path d="M9.62055 11.2326C10.0669 11.6789 10.7905 11.6789 11.2368 11.2326C11.6831 10.7863 11.6831 10.0627 11.2368 9.61636L9.62049 8.00005L11.2368 6.38375C11.6831 5.93744 11.6831 5.21382 11.2368 4.7675C10.7905 4.32119 10.0669 4.32119 9.62055 4.7675L8.00425 6.38381L6.38807 4.76763C5.94175 4.32131 5.21814 4.32131 4.77182 4.76763C4.32551 5.21394 4.32551 5.93756 4.77182 6.38387L6.38801 8.00005L4.77182 9.61624C4.32551 10.0626 4.32551 10.7862 4.77182 11.2325C5.21814 11.6788 5.94175 11.6788 6.38807 11.2325L8.00425 9.6163L9.62055 11.2326Z" fill="white"/>
          </svg>
        </span>
      </button>
      <div class="keyword-menu" id="keywordMenu" aria-hidden="true">
        <div class="keyword-menu-card">
          <div class="keyword-field">
            <div class="keyword-label-row">
              <label for="requiredKeywordInput">Include</label>
            </div>
          <div class="chip-input" data-field="required">
            <input
              id="requiredKeywordInput"
              type="text"
              placeholder="Add keywords"
              autocomplete="off"
            />
          </div>
          <div id="requiredKeywordChips" class="chip-list"></div>
        </div>
          <div class="keyword-field">
            <div class="keyword-label-row">
              <label for="avoidKeywordInput">Exclude</label>
            </div>
          <div class="chip-input" data-field="avoid">
            <input
              id="avoidKeywordInput"
              type="text"
              placeholder="Add keywords"
              autocomplete="off"
            />
          </div>
          <div id="avoidKeywordChips" class="chip-list"></div>
        </div>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="panel-rewrite" class="panel active">
  <div class="rewrite-screen-container">
    <div id="rewriteHome" class="rewrite-screen active">
      <div class="field-header">
        <label id="inputLabel" class="field-label" for="inputText">Enter copy</label>
        <div id="inputCharCount" class="char-counter">0 characters</div>
      </div>
      <div class="copy-field">
        <textarea
          id="inputText"
          class="auto-textarea"
          rows="2"
          placeholder="Select a text layer in figma, type your copy, add instructions."
        ></textarea>
      </div>
      <div class="rewrite-footer">
        <span class="rewrite-icon" aria-hidden="true">
          <svg class="guideline-icon guideline-icon--enabled" width="24" height="25" viewBox="0 0 24 25" fill="none" xmlns="http://www.w3.org/2000/svg">
            <rect x="0.5" y="0.5" width="23" height="24" rx="3.5" stroke="#00B0FF"/>
            <path d="M7.19061 18H5.55993L9.22399 7.81818H10.9988L14.6629 18H13.0322L10.1537 9.66761H10.0741L7.19061 18ZM7.46404 14.0128H12.7538V15.3054H7.46404V14.0128ZM17.6695 7.81818V18H16.1333V7.81818H17.6695Z" fill="#00B0FF"/>
          </svg>
          <svg class="guideline-icon guideline-icon--disabled" width="24" height="25" viewBox="0 0 24 25" fill="none" xmlns="http://www.w3.org/2000/svg">
            <rect x="0.5" y="0.5" width="23" height="24" rx="3.5" stroke="#ECEEF1"/>
            <path d="M7.19061 18H5.55993L9.22399 7.81818H10.9988L14.6629 18H13.0322L10.1537 9.66761H10.0741L7.19061 18ZM7.46404 14.0128H12.7538V15.3054H7.46404V14.0128ZM17.6695 7.81818V18H16.1333V7.81818H17.6695Z" fill="#ECEEF1"/>
          </svg>
        </span>
        <button id="rewrite" class="rewrite-btn" disabled aria-live="polite">
          <span class="rewrite-label">Rewrite</span>
          <span id="rewriteShimmerText" class="rewrite-shimmer" aria-hidden="true">Crafting copy…</span>
        </button>
      </div>
      <!-- tone controls removed -->

    </div>

  </div>
</div>

<div id="panel-suggestions" class="panel">
  <section class="suggestions">
    <div id="suggestionBody" class="suggestion-body centered"></div>
  </section>
  <button id="cycleTone" class="rewrite-btn secondary" disabled aria-live="polite">
    <span class="rewrite-label">More</span>
  </button>
</div>

<div id="panel-settings" class="panel">
  <div id="guidelineStatus" class="guideline-status fallback">
    <span class="status-dot"></span>
    <span class="guideline-text">Loading style guide…</span>
  </div>
  <label>API key (Gemini)</label>
  <input id="apikey" type="text" placeholder="AIza..." />
  <div class="row">
    <button id="saveKey">Save key</button>
    <button id="loadKey">Load key</button>
  </div>
  <div id="saveStatus" style="margin-top:8px;color:#555;"></div>
</div>

<script>
  // tab switching
  const tabs = {
    rewrite: { tab: document.getElementById("tab-rewrite"), panel: document.getElementById("panel-rewrite") },
    suggestions: { tab: document.getElementById("tab-suggestions"), panel: document.getElementById("panel-suggestions") },
    settings: { tab: document.getElementById("tab-settings"), panel: document.getElementById("panel-settings") },
  };
  function activate(name){
    Object.values(tabs).forEach(({tab,panel})=>{
      tab.classList.remove("active"); panel.classList.remove("active");
    });
    const target = tabs[name];
    if (target) {
      target.tab.classList.add("active");
      target.panel.classList.add("active");
    }
  }
  tabs.rewrite.tab.onclick = () => activate("rewrite");
  tabs.suggestions.tab.onclick = () => activate("suggestions");
  tabs.settings.tab.onclick = () => activate("settings");

  const btnRewrite = document.getElementById("rewrite");
  const btnCycleTone = document.getElementById("cycleTone");
  const suggestionBody = document.getElementById("suggestionBody");
  const rewriteShimmerText = document.getElementById("rewriteShimmerText");
  let lastRewriteRequest = null;
  let rewriteInProgress = false;
  const updateCycleButtonState = () => {
    if (!btnCycleTone) return;
    btnCycleTone.disabled = rewriteInProgress || !lastRewriteRequest;
  };
  const setCycleToneVisibility = (visible) => {
    if (!btnCycleTone) return;
    btnCycleTone.classList.toggle("hidden", !visible);
  };
  setCycleToneVisibility(false);
  const scrollToTop = () => {
    if (typeof window === "undefined") return;
    requestAnimationFrame(() => {
      const scroller = document.scrollingElement || document.documentElement || document.body;
      if (scroller) {
        scroller.scrollTop = 0;
      }
      if (typeof window.scrollTo === "function") {
        window.scrollTo(0, 0);
      }
      const suggestionsSection = document.querySelector("#panel-suggestions .suggestions");
      if (suggestionsSection instanceof HTMLElement) {
        suggestionsSection.scrollTop = 0;
      }
    });
  };
  const openSuggestionsTab = () => {
    activate("suggestions");
    scrollToTop();
  };
  const openRewriteTab = () => {
    activate("rewrite");
    scrollToTop();
  };
  updateCycleButtonState();
  const inputField = document.getElementById("inputText");
  const inputLabelEl = document.getElementById("inputLabel");
  const inputCharCounter = document.getElementById("inputCharCount");
  const lengthDropdownEl = document.querySelector(".length-dropdown");
  const lengthToggleBtn = document.getElementById("lengthToggle");
  const lengthToggleTitle = lengthToggleBtn?.querySelector(".length-toggle-title");
  const lengthToggleRemoveIcon = lengthToggleBtn?.querySelector(".length-icon--remove");
  const lengthMenu = document.getElementById("lengthMenu");
  const lengthMenuList = document.getElementById("lengthMenuList");
  const lengthSelectionContainer = document.querySelector(".length-toggle-selection");
  const lengthSelectionLabel = document.querySelector(".length-toggle-selection-label");
  const lengthSelectionRemove = document.querySelector(".length-toggle-selection-remove");
  const keywordDropdownEl = document.querySelector(".keyword-dropdown");
  const keywordToggleBtn = document.getElementById("keywordToggle");
  const keywordToggleRemoveIcon = keywordToggleBtn?.querySelector(".keyword-icon--remove");
  const keywordMenu = document.getElementById("keywordMenu");
  const MIN_SUGGESTIONS = 4;
  const SUGGESTION_STORAGE_KEY = "setel.rewrite.lastSuggestions";
  const toneFallbacks = [
    ["Friendly", "Caring"],
    ["Professional", "Clear"],
    ["Empathetic", "Supportive"],
    ["Persuasive", "Action-focused"],
    ["Playful", "Upbeat"],
    ["Inspirational", "Motivating"],
    ["Neutral", "Informative"],
    ["Urgent", "Time-sensitive"],
    ["Exclusive", "Premium"],
    ["Technical", "Precise"],
  ];
  const MIN_INPUT_HEIGHT = 52;
  const rewriteLabelEl = document.querySelector(".rewrite-label");
  const MODE_REWRITE = "rewrite";
  const generationMode = MODE_REWRITE;
  const MODE_CONFIG = {
    label: "Enter copy",
    placeholder: "Select a text layer in figma, type your copy, add instructions.",
    buttonLabel: "Rewrite",
    loadingText: "Crafting copy…",
  };
  const getModeConfig = () => MODE_CONFIG;
  const updateModeUI = () => {
    const config = getModeConfig();
    if (inputLabelEl) inputLabelEl.textContent = config.label;
    if (inputField && !inputField.value.trim()) {
      inputField.placeholder = config.placeholder;
    }
    if (rewriteLabelEl) rewriteLabelEl.textContent = config.buttonLabel;
    if (!rewriteInProgress && rewriteShimmerText) {
      rewriteShimmerText.textContent = config.loadingText;
    }
  };
  updateModeUI();
  const getModeLoadingText = () => getModeConfig().loadingText;
  const updateRewriteButtonState = () => {
    if (!btnRewrite) return;
    if (rewriteInProgress) {
      btnRewrite.disabled = true;
      return;
    }
    const hasText = Boolean(inputField?.value.trim());
    btnRewrite.disabled = !hasText;
  };
  const setRewriteLoadingState = (isLoading, text) => {
    rewriteInProgress = Boolean(isLoading);
    if (btnRewrite) {
      btnRewrite.classList.toggle("is-loading", rewriteInProgress);
      btnRewrite.setAttribute("aria-busy", rewriteInProgress ? "true" : "false");
    }
    const labelText = typeof text === "string" && text.trim() ? text : getModeLoadingText();
    if (rewriteShimmerText) {
      rewriteShimmerText.textContent = labelText;
    }
    if (!rewriteInProgress) {
      updateModeUI();
    }
    updateRewriteButtonState();
    updateCycleButtonState();
  };
  const autoResizeTextarea = (element, minHeight = MIN_INPUT_HEIGHT) => {
    if (!element) return;
    element.style.height = "auto";
    const nextHeight = Math.max(element.scrollHeight, minHeight);
    element.style.height = `${nextHeight}px`;
  };
  const resizeRewriteInput = () => {
    autoResizeTextarea(inputField, MIN_INPUT_HEIGHT);
  };

  const geminiKeyInput = document.getElementById("apikey");
  const saveKeyBtn = document.getElementById("saveKey");
  const loadKeyBtn = document.getElementById("loadKey");
  const saveStatus = document.getElementById("saveStatus");
  const guidelineStatus = document.getElementById("guidelineStatus");
  const guidelineStatusText = guidelineStatus?.querySelector(".guideline-text");
  const requiredKeywordInput = document.getElementById("requiredKeywordInput");
  const avoidKeywordInput = document.getElementById("avoidKeywordInput");
  const requiredKeywordChips = document.getElementById("requiredKeywordChips");
  const avoidKeywordChips = document.getElementById("avoidKeywordChips");
  const manualKeywordState = {
    required: [],
    avoid: [],
  };
  const hasManualKeywords = () =>
    (manualKeywordState.required?.length || 0) + (manualKeywordState.avoid?.length || 0) > 0;
  const keywordInputs = {
    required: requiredKeywordInput,
    avoid: avoidKeywordInput,
  };
  const keywordChipLists = {
    required: requiredKeywordChips,
    avoid: avoidKeywordChips,
  };
  const keywordTypes = ["required", "avoid"];
  const sanitizeKeyword = (value = "") => value.replace(/\s+/g, " ").trim();
  const updateKeywordToggleState = () => {
    const hasKeywords = hasManualKeywords();
    keywordToggleBtn?.classList.toggle("has-selection", hasKeywords);
  };
  const renderKeywordChips = (type) => {
    const listEl = keywordChipLists[type];
    if (!listEl) return;
    listEl.innerHTML = "";
    const keywords = manualKeywordState[type] || [];
    keywords.forEach((keyword, index) => {
      const chip = document.createElement("span");
      chip.className = "keyword-chip";
      chip.classList.add(type === "required" ? "include-chip" : "avoid-chip");
      const label = document.createElement("span");
      label.textContent = keyword;
      const removeBtn = document.createElement("button");
      removeBtn.type = "button";
      removeBtn.className = "chip-remove";
      removeBtn.setAttribute("aria-label", `Remove keyword "${keyword}"`);
      const iconName = type === "required" ? "Icons/Remove.svg" : "Icons/Remove(red).svg";
    if (type === "required") {
      removeBtn.innerHTML = `
        <svg width="16" height="16" viewBox="0 0 16 16" fill="none" aria-hidden="true" xmlns="http://www.w3.org/2000/svg">
          <path d="M0 8C0 12.4183 3.58172 16 8 16C12.4183 16 16 12.4183 16 8C16 3.58172 12.4183 0 8 0C3.58172 0 0 3.58172 0 8Z" fill="#00B0FF"/>
          <path d="M9.62055 11.2326C10.0669 11.6789 10.7905 11.6789 11.2368 11.2326C11.6831 10.7863 11.6831 10.0627 11.2368 9.61636L9.62049 8.00005L11.2368 6.38375C11.6831 5.93744 11.6831 5.21382 11.2368 4.7675C10.7905 4.32119 10.0669 4.32119 9.62055 4.7675L8.00425 6.38381L6.38807 4.76763C5.94175 4.32131 5.21814 4.32131 4.77182 4.76763C4.32551 5.21394 4.32551 5.93756 4.77182 6.38387L6.38801 8.00005L4.77182 9.61624C4.32551 10.0626 4.32551 10.7862 4.77182 11.2325C5.21814 11.6788 5.94175 11.6788 6.38807 11.2325L8.00425 9.6163L9.62055 11.2326Z" fill="white"/>
        </svg>
      `;
    } else {
      removeBtn.innerHTML = `
        <svg width="16" height="16" viewBox="0 0 16 16" fill="none" aria-hidden="true" xmlns="http://www.w3.org/2000/svg">
          <path d="M0 8C0 12.4183 3.58172 16 8 16C12.4183 16 16 12.4183 16 8C16 3.58172 12.4183 0 8 0C3.58172 0 0 3.58172 0 8Z" fill="#F44336"/>
          <path d="M9.62055 11.2326C10.0669 11.6789 10.7905 11.6789 11.2368 11.2326C11.6831 10.7863 11.6831 10.0627 11.2368 9.61636L9.62049 8.00005L11.2368 6.38375C11.6831 5.93744 11.6831 5.21382 11.2368 4.7675C10.7905 4.32119 10.0669 4.32119 9.62055 4.7675L8.00425 6.38381L6.38807 4.76763C5.94175 4.32131 5.21814 4.32131 4.77182 4.76763C4.32551 5.21394 4.32551 5.93756 4.77182 6.38387L6.38801 8.00005L4.77182 9.61624C4.32551 10.0626 4.32551 10.7862 4.77182 11.2325C5.21814 11.6788 5.94175 11.6788 6.38807 11.2325L8.00425 9.6163L9.62055 11.2326Z" fill="white"/>
        </svg>
      `;
    }
      removeBtn.addEventListener("click", () => {
        manualKeywordState[type].splice(index, 1);
        renderKeywordChips(type);
        handleGuidelineControlsChanged();
      });
      chip.appendChild(label);
      chip.appendChild(removeBtn);
      listEl.appendChild(chip);
    });
    updateKeywordToggleState();
  };
  const clearAllManualKeywords = () => {
    let changed = false;
    keywordTypes.forEach((type) => {
      if (manualKeywordState[type].length) {
        manualKeywordState[type].length = 0;
        changed = true;
      }
      const input = keywordInputs[type];
      if (input) input.value = "";
      renderKeywordChips(type);
    });
    if (!changed) {
      updateKeywordToggleState();
    } else {
      handleGuidelineControlsChanged();
    }
  };
  const addManualKeyword = (type, rawValue) => {
    const keyword = sanitizeKeyword(rawValue);
    if (!keyword) return false;
    const keywords = manualKeywordState[type];
    const exists = keywords.some((value) => value.toLowerCase() === keyword.toLowerCase());
    if (exists) return false;
    keywords.push(keyword);
    renderKeywordChips(type);
    handleGuidelineControlsChanged();
    return true;
  };
  const commitManualKeywordFromInput = (type) => {
    const input = keywordInputs[type];
    if (!input) return;
    if (addManualKeyword(type, input.value)) {
      input.value = "";
    }
  };
  const commitAllManualKeywords = () => {
    keywordTypes.forEach((type) => commitManualKeywordFromInput(type));
  };
  const handleKeywordInputKeydown = (event, type) => {
    if (!event) return;
    if (event.key === "Enter" || event.key === ",") {
      event.preventDefault();
      commitManualKeywordFromInput(type);
      return;
    }
    if (
      event.key === "Backspace" &&
      event.target instanceof HTMLInputElement &&
      !event.target.value.trim() &&
      manualKeywordState[type].length
    ) {
      manualKeywordState[type].pop();
      renderKeywordChips(type);
      handleGuidelineControlsChanged();
      event.preventDefault();
    }
  };
  keywordTypes.forEach((type) => {
    const input = keywordInputs[type];
    if (!input) return;
    input.addEventListener("keydown", (event) => handleKeywordInputKeydown(event, type));
    input.addEventListener("blur", () => commitManualKeywordFromInput(type));
  });
  updateKeywordToggleState();
  const formatCharCount = (count) => `${count} character${count === 1 ? "" : "s"}`;
  const updateInputCharCount = () => {
    if (!inputCharCounter) return;
    const value = inputField?.value || "";
    inputCharCounter.textContent = formatCharCount(value.length);
  };
  const SUGGESTION_INITIAL_DELAY = 320;
  const SUGGESTION_REVEAL_STEP = 180;
  const SKELETON_MIN_DISPLAY_MS = 1100;
  let suggestionRevealTimers = [];
  let skeletonVisibleSince = 0;
  let skeletonActive = false;
  const reducedMotionQuery =
    typeof window !== "undefined" && window.matchMedia
      ? window.matchMedia("(prefers-reduced-motion: reduce)")
      : null;
  const prefersReducedMotion = () => Boolean(reducedMotionQuery?.matches);
  const clearSuggestionRevealTimers = () => {
    suggestionRevealTimers.forEach((timerId) => clearTimeout(timerId));
    suggestionRevealTimers = [];
    skeletonVisibleSince = 0;
    skeletonActive = false;
  };
  const resetSuggestionCardInteractivity = (card) => {
    if (!card) return;
    card.classList.remove("is-interactive", "revealed");
    card.removeAttribute("role");
    card.removeAttribute("tabindex");
    card.removeAttribute("data-text");
  };
  const createSkeletonCardElement = () => {
    const card = document.createElement("article");
    card.className = "suggestion-card skeleton";
    resetSuggestionCardInteractivity(card);
    card.innerHTML = `
      <div class="skeleton-line skeleton-block long"></div>
      <div class="skeleton-line skeleton-block long"></div>
      <div class="skeleton-meta">
        <span class="skeleton-pill skeleton-block"></span>
      </div>
    `;
    return card;
  };
  const renderSkeletonPlaceholders = (count = MIN_SUGGESTIONS) => {
    if (!suggestionBody) return { list: null, cards: [] };
    clearSuggestionRevealTimers();
    suggestionBody.className = "suggestion-body";
    suggestionBody.innerHTML = "";
    const list = document.createElement("div");
    list.className = "suggestions-list is-loading";
    suggestionBody.appendChild(list);
    const total = Math.max(1, Number(count) || 0);
    const cards = [];
    for (let i = 0; i < total; i += 1) {
      const card = createSkeletonCardElement();
      list.appendChild(card);
      cards.push(card);
    }
    skeletonVisibleSince =
      typeof performance !== "undefined" && performance.now ? performance.now() : Date.now();
    skeletonActive = true;
    return { list, cards };
  };
  const revealCardContent = (card, item) => {
    if (!card) return;
    card.classList.remove("skeleton");
    card.dataset.text = item.text;
    card.innerHTML = `
      <p>${item.text}</p>
      <div class="suggestion-meta">
        <span class="suggestion-char">${formatCharCount(item.charCount ?? item.text.length)}</span>
      </div>
    `;
    card.setAttribute("role", "button");
    card.tabIndex = 0;
    card.classList.add("is-interactive");
    card.addEventListener("click", handleSuggestionCardClick);
    card.addEventListener("keydown", handleSuggestionCardKeydown);
    card.classList.add("revealing");
    requestAnimationFrame(() => {
      card.classList.remove("revealing");
      card.classList.add("revealed");
    });
  };
  const scheduleSuggestionReveal = (cards, items, list) => {
    if (!cards.length || !items.length) return;
    const baseDelay = prefersReducedMotion() ? 0 : SUGGESTION_INITIAL_DELAY;
    const stepDelay = prefersReducedMotion() ? 0 : SUGGESTION_REVEAL_STEP;
    cards.forEach((card, idx) => {
      const now = typeof performance !== "undefined" && performance.now ? performance.now() : Date.now();
      const elapsed = Math.max(0, now - skeletonVisibleSince);
      const minVisibleOffset =
        skeletonActive && !prefersReducedMotion()
          ? Math.max(SKELETON_MIN_DISPLAY_MS - elapsed, 0)
          : 0;
      const timer = setTimeout(() => {
        revealCardContent(card, items[idx]);
        if (idx === cards.length - 1 && list) {
          list.classList.remove("is-loading");
          skeletonActive = false;
          skeletonVisibleSince = 0;
        }
      }, baseDelay + idx * stepDelay + minVisibleOffset);
      suggestionRevealTimers.push(timer);
    });
  };

  const fallbackGuideline = Object.freeze({
    name: "Warm lower-case headings",
    instructions:
      "Write 2-6 word lower-case headings with a warm, appreciative, enthusiastic tone. Keep copy mobile friendly and avoid emojis unless explicitly requested.",
    examples: [
      "thanks for being here",
      "we love having you",
      "you're in great company",
    ],
  });

  const guidelineMeta = {
    rewriteOverview: "",
    rewriteRequirements: [],
  };
  const defaultLengthGuide = {
    overview: "We'll automatically mix short (0-32), medium (33-72), and long (73-140) unless you pick a target.",
    options: {
      short: {
        label: "Short",
        min_chars: 0,
        max_chars: 32,
        range_hint: "0-32 characters",
        structure: "2-5 words. Verb + noun/object. No filler.",
        use_cases: ["Primary buttons", "Badges/chips", "Toast titles"],
        notes: "Still state the action clearly.",
      },
      medium: {
        label: "Medium",
        min_chars: 33,
        max_chars: 72,
        range_hint: "33-72 characters",
        structure: "1 sentence. Verb + benefit + helper clause.",
        use_cases: ["Push notifications", "Modals", "List tiles"],
        notes: "Add context first, then action. Avoid small talk.",
      },
      long: {
        label: "Long",
        min_chars: 73,
        max_chars: 140,
        range_hint: "73-140 characters",
        structure: "1-2 sentences. Outcome first, action second.",
        use_cases: ["Empty states", "Education cards", "Tooltips"],
        notes: "Max two sentences so it stays scannable.",
      },
    },
  };
  const cleanString = (value) => (typeof value === "string" ? value.trim() : "");
  const toNumberOrUndefined = (value) =>
    typeof value === "number" && Number.isFinite(value) ? value : undefined;
  const formatRangeLabel = (min, max, fallback) => {
    if (cleanString(fallback)) return cleanString(fallback);
    const hasMin = typeof min === "number";
    const hasMax = typeof max === "number";
    if (hasMin && hasMax) return `${min}-${max} characters`;
    if (hasMax) return `≤${max} characters`;
    if (hasMin) return `≥${min} characters`;
    return "";
  };
  const normalizeLengthGuide = (guide) => {
    const source = guide?.length_presets || guide || {};
    const overview = cleanString(source.overview);
    const options = [];
    const entries = source.options && typeof source.options === "object" ? source.options : {};
    Object.entries(entries).forEach(([id, spec]) => {
      if (!spec || typeof spec !== "object") return;
      const label = cleanString(spec.label) || cleanString(id);
      if (!label) return;
      const minChars = toNumberOrUndefined(spec.min_chars);
      const maxChars = toNumberOrUndefined(spec.max_chars);
      const rangeLabel = formatRangeLabel(minChars, maxChars, spec.range_hint);
      const structure = cleanString(spec.structure);
      const useCases = Array.isArray(spec.use_cases)
        ? spec.use_cases
            .map((entry) => cleanString(entry))
            .filter(Boolean)
        : [];
      const useCasesText = useCases.length ? `Use for: ${useCases.join(", ")}.` : "";
      const notes = cleanString(spec.notes);
      const summaryParts = [structure, useCasesText, notes].filter(Boolean);
      options.push({
        id,
        label,
        minChars,
        maxChars,
        rangeLabel,
        structure,
        useCasesText,
        notes,
        summary: summaryParts.join(" "),
      });
    });
    return {
      overview,
      options,
    };
  };
  const initialLengthState = normalizeLengthGuide(defaultLengthGuide);
  let lengthPresets = initialLengthState.options;
  let lengthOverviewText = initialLengthState.overview;
  let selectedLengthId = "";
  const getLengthPresetById = (value) => lengthPresets.find((preset) => preset.id === value);
  const updateSelectedLengthUI = () => {
    if (!lengthSelectionContainer || !lengthSelectionLabel) return;
    const preset = selectedLengthId ? getLengthPresetById(selectedLengthId) : null;
    const hasPreset = Boolean(preset && preset.label);
    lengthToggleBtn?.classList.toggle("has-selection", hasPreset);
    lengthToggleTitle && (lengthToggleTitle.textContent = hasPreset ? preset?.label : "Length");
    lengthToggleBtn?.setAttribute("aria-label", hasPreset ? `Length: ${preset?.label}` : "Length");
    if (hasPreset) {
      lengthSelectionLabel.textContent = preset.label;
      lengthSelectionContainer.classList.add("visible");
      return;
    }
    lengthSelectionLabel.textContent = "";
    lengthSelectionContainer.classList.remove("visible");
  };
  const clearLengthSelection = () => {
    selectedLengthId = "";
    updateLengthDisplays();
    lengthToggleBtn?.focus();
    handleGuidelineControlsChanged();
  };
  const updateLengthDisplays = () => {
    if (lengthMenuList) {
      const activeId = selectedLengthId || "";
      lengthMenuList.querySelectorAll(".length-option").forEach((option) => {
        option.classList.toggle("selected", option.getAttribute("data-length-id") === activeId);
      });
    }
    updateSelectedLengthUI();
  };
  let lengthMenuVisible = false;
  const setLengthMenuVisibility = (visible) => {
    lengthMenuVisible = visible;
    if (lengthMenu) {
      lengthMenu.classList.toggle("visible", visible);
      lengthMenu.setAttribute("aria-hidden", visible ? "false" : "true");
    }
    if (lengthToggleBtn) {
      lengthToggleBtn.setAttribute("aria-expanded", visible ? "true" : "false");
      lengthToggleBtn.classList.toggle("active", visible);
    }
  };
  const closeLengthMenu = () => setLengthMenuVisibility(false);
  const toggleLengthMenu = () => setLengthMenuVisibility(!lengthMenuVisible);
  let keywordMenuVisible = false;
  const setKeywordMenuVisibility = (visible) => {
    keywordMenuVisible = visible;
    if (keywordMenu) {
      keywordMenu.classList.toggle("visible", visible);
      keywordMenu.setAttribute("aria-hidden", visible ? "false" : "true");
    }
    if (keywordToggleBtn) {
      keywordToggleBtn.setAttribute("aria-expanded", visible ? "true" : "false");
    }
  };
  const toggleKeywordMenu = (event) => {
    event?.stopPropagation();
    if (!keywordMenuVisible) {
      closeLengthMenu();
    }
    setKeywordMenuVisibility(!keywordMenuVisible);
  };
  const closeKeywordMenu = () => setKeywordMenuVisibility(false);
  const handleKeywordIconClick = (event) => {
    if (!hasManualKeywords()) return;
    event.stopPropagation();
    event.preventDefault();
    clearAllManualKeywords();
  };
  keywordToggleRemoveIcon?.addEventListener("click", handleKeywordIconClick);
  const renderLengthMenuOptions = () => {
    if (!lengthMenuList) return;
    lengthMenuList.innerHTML = "";
    const addOption = ({ id, label }) => {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "length-option";
      btn.setAttribute("data-length-id", id || "");
      btn.textContent = label;
      btn.addEventListener("click", () => {
        selectedLengthId = id || "";
        updateLengthDisplays();
        closeLengthMenu();
        handleGuidelineControlsChanged();
      });
      lengthMenuList.appendChild(btn);
    };
    lengthPresets.forEach((preset) => {
      addOption({
        id: preset.id,
        label: preset.label,
      });
    });
    if (selectedLengthId && !getLengthPresetById(selectedLengthId)) {
      selectedLengthId = "";
    }
    updateLengthDisplays();
  };
  const applyLengthGuide = (guide) => {
    const normalized = normalizeLengthGuide(guide?.length_presets ? guide : defaultLengthGuide);
    if (normalized.options.length) {
      lengthPresets = normalized.options;
      lengthOverviewText = normalized.overview || defaultLengthGuide.overview;
    } else {
      const fallback = normalizeLengthGuide(defaultLengthGuide);
      lengthPresets = fallback.options;
      lengthOverviewText = fallback.overview;
    }
    if (!getLengthPresetById(selectedLengthId)) {
      selectedLengthId = "";
    }
    renderLengthMenuOptions();
  };
  renderLengthMenuOptions();

  const handleLengthIconClick = (event) => {
    if (!selectedLengthId) {
      return;
    }
    event.stopPropagation();
    event.preventDefault();
    clearLengthSelection();
    closeLengthMenu();
  };
  lengthToggleRemoveIcon?.addEventListener("click", handleLengthIconClick);
  lengthToggleBtn?.addEventListener("click", (event) => {
    event.stopPropagation();
    closeKeywordMenu();
    toggleLengthMenu();
  });
  lengthSelectionRemove?.addEventListener("click", (event) => {
    event.stopPropagation();
    event.preventDefault();
    clearLengthSelection();
  });
  lengthSelectionRemove?.addEventListener("keydown", (event) => {
    if (event.key === "Enter" || event.key === " ") {
      event.preventDefault();
      clearLengthSelection();
    }
  });
  keywordToggleBtn?.addEventListener("click", toggleKeywordMenu);
  lengthMenu?.addEventListener("click", (event) => {
    event.stopPropagation();
  });
  keywordMenu?.addEventListener("click", (event) => {
    event.stopPropagation();
  });
  document.addEventListener("click", (event) => {
    if (lengthDropdownEl && !lengthDropdownEl.contains(event.target)) {
      closeLengthMenu();
    }
    if (keywordDropdownEl && !keywordDropdownEl.contains(event.target)) {
      closeKeywordMenu();
    }
  });
  document.addEventListener("keydown", (event) => {
    if (event.key === "Escape") {
      closeLengthMenu();
      closeKeywordMenu();
    }
  });

  const shortenHelperText = (text) => {
    const clean = String(text || "").trim();
    if (!clean) return "";
    const withoutLead = clean
      .replace(
        /^(Use|Keep|Explain|Provide|Offer|Make|Add|Focus on|Highlight|Remember|Ensure|Avoid|Encourage|Maintain|Share|Deliver|Emphasize|Support)\b[\s,:-]*/i,
        ""
      )
      .trim();
    const tightened = withoutLead
      .replace(/\b(make sure to|be sure to|try to|aim to|you should|you must)\b/gi, "")
      .replace(/\b(please|really|just)\b/gi, "")
      .replace(/\b(your|their)\s+(users?|audience|customers?)\b/gi, "$2")
      .replace(/\s{2,}/g, " ")
      .trim();
    const candidate = tightened || withoutLead || clean;
    return candidate.replace(/[.:;]+$/, "").trim();
  };

  const applyGuidelineMeta = (guide) => {
    const rewritePrompt = guide?.rewritePrompt || {};
    guidelineMeta.rewriteOverview =
      typeof rewritePrompt.overview === "string" ? rewritePrompt.overview.trim() : "";
    guidelineMeta.rewriteRequirements = Array.isArray(rewritePrompt.requirements)
      ? rewritePrompt.requirements
          .map((item) => (typeof item === "string" ? item.trim() : ""))
          .filter(Boolean)
      : [];
    applyLengthGuide(guide);
  };

  const setGuidelineIndicator = (state, text) => {
    if (!guidelineStatus || !guidelineStatusText) return;
    guidelineStatus.classList.remove("loaded", "fallback", "error");
    guidelineStatus.classList.add(state);
    guidelineStatusText.textContent = text;
    document.body.classList.remove("guideline-loaded", "guideline-fallback", "guideline-error");
    document.body.classList.add(`guideline-${state}`);
  };

  let guidelineReference = null;
  const getGuidelinePayload = () => {
    if (guidelineReference) return guidelineReference;
    setGuidelineIndicator("fallback", "Using fallback style guide.");
    return fallbackGuideline;
  };
  const buildGuidelinePayload = () => {
    const base = getGuidelinePayload();
    const payload = base && typeof base === "object" ? { ...base } : {};
    delete payload.tonePreference;
    delete payload.styleFilters;
    const manualRequired = manualKeywordState.required.slice();
    const manualAvoid = manualKeywordState.avoid.slice();
    if (manualRequired.length || manualAvoid.length) {
      const mergeKeywordLists = (existing, additions) => {
        const current = Array.isArray(existing)
          ? existing
              .map((item) => (typeof item === "string" ? item.trim() : ""))
              .filter(Boolean)
          : [];
        const merged = [];
        const seen = new Set();
        current.concat(additions).forEach((value) => {
          const trimmed = sanitizeKeyword(value);
          if (!trimmed) return;
          const key = trimmed.toLowerCase();
          if (seen.has(key)) return;
          seen.add(key);
          merged.push(trimmed);
        });
        return merged;
      };
      const validationSource =
        payload.validation && typeof payload.validation === "object"
          ? { ...payload.validation }
          : {};
      if (manualRequired.length) {
        validationSource.required_phrases = mergeKeywordLists(
          validationSource.required_phrases,
          manualRequired
        );
      }
      if (manualAvoid.length) {
        validationSource.avoid_phrases = mergeKeywordLists(validationSource.avoid_phrases, manualAvoid);
      }
      payload.validation = validationSource;
      payload.manualConstraints = {
        required: manualRequired,
        avoid: manualAvoid,
      };
    }
    const activeLengthPreset = selectedLengthId ? getLengthPresetById(selectedLengthId) : null;
    if (activeLengthPreset) {
      const lengthPreference = {
        id: activeLengthPreset.id,
        label: activeLengthPreset.label,
        range_hint: activeLengthPreset.rangeLabel,
        structure: activeLengthPreset.structure,
        description: activeLengthPreset.summary,
      };
      if (typeof activeLengthPreset.minChars === "number") {
        lengthPreference.min_chars = activeLengthPreset.minChars;
      }
      if (typeof activeLengthPreset.maxChars === "number") {
        lengthPreference.max_chars = activeLengthPreset.maxChars;
      }
      payload.length_preference = lengthPreference;
    } else if (payload.length_preference) {
      delete payload.length_preference;
    }
    return payload;
  };
  const handleGuidelineControlsChanged = () => {
    if (lastRewriteRequest) {
      lastRewriteRequest.guideline = buildGuidelinePayload();
    }
    postToPlugin({ type: "reset-tone-cycle" });
  };
  setGuidelineIndicator("fallback", "Loading style guide…");

  const resolveTargetOrigin = () => {
    try {
      const ref = document.referrer;
      if (ref && ref !== "null") {
        return new URL(ref).origin;
      }
    } catch (err) {
      console.warn("Could not parse parent origin:", err);
    }
    return "https://www.figma.com";
  };

  const targetOrigin = resolveTargetOrigin();

  const postToPlugin = (pluginMessage) => {
    if (!window.parent || window.parent === window) {
      console.warn("Figma host unavailable; skipping postMessage", pluginMessage);
      return;
    }
    window.parent.postMessage({ pluginMessage }, targetOrigin);
  };
  const applySuggestionText = (text) => {
    if (typeof text !== "string" || !text.trim()) return;
    if (inputField) {
      inputField.value = text;
      inputField.dispatchEvent(new Event("input"));
    }
    postToPlugin({ type: "apply-text", text });
  };
  const activateSuggestionCard = (target) => {
    const card = target instanceof HTMLElement ? target : null;
    if (!card || card.classList.contains("skeleton")) return;
    const text = card.getAttribute("data-text") || "";
    if (!text.trim()) return;
    applySuggestionText(text);
  };
  const handleSuggestionCardClick = (event) => {
    if (!event?.currentTarget) return;
    event.preventDefault();
    activateSuggestionCard(event.currentTarget);
  };
  const handleSuggestionCardKeydown = (event) => {
    if (!event?.currentTarget) return;
    const key = event.key;
    if (key === "Enter" || key === " ") {
      event.preventDefault();
      activateSuggestionCard(event.currentTarget);
    }
  };

  const renderEmptyState = () => {
    if (restoreSuggestionsFromStorage()) {
      return;
    }
    setCycleToneVisibility(false);
    clearSuggestionRevealTimers();
    suggestionBody.className = "suggestion-body centered";
    suggestionBody.innerHTML = `
      <div class="empty-arrow">↑</div>
      <p>Paste copy to rewrite, then click the button for fresh suggestions.</p>
    `;
  };

  const renderLoading = (text, skeletonCount = MIN_SUGGESTIONS) => {
    openSuggestionsTab();
    setCycleToneVisibility(false);
    renderSkeletonPlaceholders(skeletonCount);
    const labelText = typeof text === "string" && text.trim() ? text : getModeLoadingText();
    if (rewriteShimmerText) {
      rewriteShimmerText.textContent = labelText;
    }
  };

  const renderStatus = (text) => {
    setCycleToneVisibility(false);
    clearSuggestionRevealTimers();
    suggestionBody.className = "suggestion-body centered";
    suggestionBody.innerHTML = `<p>${text}</p>`;
  };

  const renderError = (text) => {
    setCycleToneVisibility(false);
    clearSuggestionRevealTimers();
    suggestionBody.className = "suggestion-body centered error";
    suggestionBody.innerHTML = `<p>${text || "Something went wrong. Try again in a bit."}</p>`;
  };

  const renderSuggestions = (items) => {
    if (!items.length) {
      renderStatus("No response.");
      return;
    }

    const { list, cards } = renderSkeletonPlaceholders(items.length);
    if (!cards.length || !list) {
      skeletonActive = false;
      skeletonVisibleSince = 0;
    const fallbackCards = items
      .map(
        (item) => `
        <article class="suggestion-card">
          <p>${item.text}</p>
          <div class="suggestion-meta">
            <span class="suggestion-char">${formatCharCount(item.charCount ?? item.text.length)}</span>
          </div>
        </article>`
        ) 
      .join("");
    suggestionBody.className = "suggestion-body";
    suggestionBody.innerHTML = `<div class="suggestions-list">${fallbackCards}</div>`;
    setCycleToneVisibility(true);
    updateCycleButtonState();
    return;
  }
  scheduleSuggestionReveal(cards, items, list);
  setCycleToneVisibility(true);
  updateCycleButtonState();
  };

  const saveSuggestionsSnapshot = (payload) => {
    try {
      if (!window.localStorage) return;
      const serialized = JSON.stringify(payload);
      window.localStorage.setItem(SUGGESTION_STORAGE_KEY, serialized);
    } catch (err) {
      console.warn("Unable to save suggestions to storage:", err);
    }
  };

  const loadSuggestionsSnapshot = () => {
    try {
      if (!window.localStorage) return null;
      const raw = window.localStorage.getItem(SUGGESTION_STORAGE_KEY);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!parsed || !Array.isArray(parsed.suggestions) || !parsed.suggestions.length) {
        return null;
      }
      return parsed;
    } catch (err) {
      console.warn("Unable to read suggestions from storage:", err);
      return null;
    }
  };

  const restoreSuggestionsFromStorage = () => {
    const snapshot = loadSuggestionsSnapshot();
    if (!snapshot) return false;
    const { suggestions } = snapshot;
    if (!Array.isArray(suggestions) || !suggestions.length) {
      return false;
    }
    openSuggestionsTab();
    renderSuggestions(suggestions);
    return true;
  };

  const stripFormatting = (line) =>
    line
      .replace(/[*_`]/g, "")
      .replace(/^\d+[\.)-]*\s*/, "")
      .replace(/^[-•*]+\s*/, "")
      .replace(/\s+/g, " ")
      .trim();
  const stripTrailingCharCount = (text) => {
    if (!text) return text;
    return text.replace(/\s*\(\s*~?\d+\s*(?:char(?:s)?|character(?:s)?)\s*\)\s*$/i, "").trim();
  };

  const classifyLength = (count) => {
    if (count <= 45) return "Short";
    if (count <= 80) return "Medium";
    return "Long";
  };
  const removeLeadingIndex = (value = "") => value.replace(/^\s*\d+[\.\)\-]\s*/, "");
  const buildSuggestions = (raw) => {
    if (!raw) return [];

    const expandedRaw = raw.replace(/(\d+[\.)-])/g, "\n$1");
    let blockSegments = expandedRaw.split(/\n{2,}/);
    if (blockSegments.length === 1) {
      blockSegments = expandedRaw.split(/\n+/);
    }
    const blocks = blockSegments
      .map((block) => stripFormatting(block))
      .map((block) => stripTrailingCharCount(block))
      .map((block) => removeLeadingIndex(block))
      .filter(Boolean);

    return blocks.map((text, idx) => {
      const charCount = text.length;
      return {
        text,
        charCount,
        lengthLabel: classifyLength(charCount),
        score: Math.max(80, 95 - idx * 2),
        tones: toneFallbacks[idx % toneFallbacks.length],
      };
    });
  };

  const applySelectionText = (text) => {
    if (!text) return;
    inputField.value = text;
    inputField.dispatchEvent(new Event("input"));
  };

  btnRewrite.onclick = async () => {
    commitAllManualKeywords();
    const text = inputField.value.trim();
    if (!text) {
      alert("Please enter some text.");
      return;
    }
    const mode = generationMode;
    const guidelinePayload = buildGuidelinePayload();
    lastRewriteRequest = {
      text,
      guideline: guidelinePayload,
      mode,
    };
    updateCycleButtonState();
    setRewriteLoadingState(true);
    renderLoading();

    const key = geminiKeyInput ? geminiKeyInput.value.trim() : "";
    if (!key) {
      postToPlugin({ type: "load-key" });
      renderLoading("Loading saved key…");
      window.__pendingText = text;
      window.__pendingGuideline = guidelinePayload;
      window.__pendingMode = mode;
      return;
    }

    delete window.__pendingGuideline;
    delete window.__pendingMode;
      postToPlugin({
        type: "rewrite",
        key,
        text,
        guideline: guidelinePayload,
        mode,
      });
    };

  btnCycleTone?.addEventListener("click", () => {
    if (!lastRewriteRequest) return;
    commitAllManualKeywords();
    const key = geminiKeyInput ? geminiKeyInput.value.trim() : "";
    if (!key) {
      postToPlugin({ type: "load-key" });
      renderLoading("Loading saved key…");
      window.__pendingText = lastRewriteRequest.text;
      window.__pendingGuideline = lastRewriteRequest.guideline;
      window.__pendingMode = lastRewriteRequest.mode;
      return;
    }
    setRewriteLoadingState(true);
    renderLoading();
    postToPlugin({
      type: "cycle-tone",
      key,
      text: lastRewriteRequest.text,
      guideline: lastRewriteRequest.guideline,
      mode: lastRewriteRequest.mode,
    });
  });

  inputField.addEventListener("input", () => {
    const hasText = Boolean(inputField.value.trim());
    updateRewriteButtonState();
    updateInputCharCount();
    resizeRewriteInput();
    if (!hasText && !window.__pendingText) {
      renderEmptyState();
    }
  });

  // settings save/load
  saveKeyBtn.onclick = () => {
    const key = geminiKeyInput.value.trim();
    postToPlugin({ type: "save-key", key });
    saveStatus.textContent = "Saving…";
  };
  loadKeyBtn.onclick = () => {
    postToPlugin({ type: "load-key" });
    saveStatus.textContent = "Loading…";
  };

  // messages from main
  onmessage = (event) => {
    const msg = event.data.pluginMessage;

    if (msg?.type === "guideline-default") {
      if (msg.error) {
        guidelineReference = null;
        setGuidelineIndicator("error", "Couldn't load style guide. Using fallback.");
        guidelineMeta.rewriteOverview = "";
        guidelineMeta.rewriteRequirements = [];
        applyLengthGuide(null);
      } else if (msg.guideline) {
        guidelineReference = msg.guideline;
        setGuidelineIndicator("loaded", "Using structured style guide.");
        applyGuidelineMeta(msg.guideline);
      } else {
        guidelineReference = null;
        setGuidelineIndicator("fallback", "Using fallback style guide.");
        guidelineMeta.rewriteOverview = "";
        guidelineMeta.rewriteRequirements = [];
        applyLengthGuide(null);
      }
      return;
    }

    if (msg?.type === "key-saved") {
      saveStatus.textContent = msg.error ? ("Save failed: " + msg.error) : "Key saved.";
      if (!msg.error && typeof msg.key === "string") {
        geminiKeyInput.value = msg.key;
      }
      return;
    }
    if (msg?.type === "key-loaded") {
      if (msg.error) {
        saveStatus.textContent = "Load failed: " + msg.error;
        setRewriteLoadingState(false);
        if (window.__pendingText) {
    openSuggestionsTab();
          renderStatus("Couldn't load your API key. Add it in Settings to try again.");
          delete window.__pendingText;
          delete window.__pendingGuideline;
          activate("settings");
        }
        return;
      }

      const loadedKeyRaw = typeof msg.key === "string" ? msg.key : "";
      const loadedKey = loadedKeyRaw.trim();

      geminiKeyInput.value = loadedKeyRaw;
      saveStatus.textContent = loadedKey ? "Key loaded." : "No key saved yet.";

      if (window.__pendingText) {
        if (loadedKey) {
          const text = window.__pendingText;
          const guide = window.__pendingGuideline || buildGuidelinePayload();
          const pendingMode = window.__pendingMode || generationMode;
          delete window.__pendingText;
          delete window.__pendingGuideline;
          delete window.__pendingMode;
          postToPlugin({
            type: "rewrite",
            key: loadedKey,
            text,
            guideline: guide,
            mode: pendingMode,
          });
          setRewriteLoadingState(true);
          renderLoading();
        } else {
          setRewriteLoadingState(false);
          openSuggestionsTab();
          renderStatus("Add your Gemini API key in Settings to generate copy suggestions.");
          delete window.__pendingText;
          delete window.__pendingGuideline;
          delete window.__pendingMode;
          activate("settings");
        }
      }
      return;
    }
    if (msg?.type === "error") {
      const errText =
        typeof msg.error === "string"
          ? msg.error
          : msg && msg.error && msg.error.message
          ? String(msg.error.message)
          : "Unknown error.";
      console.error("Gemini rewrite error:", msg.error);
      setRewriteLoadingState(false);
      openSuggestionsTab();
      renderError("Generation failed: " + errText);
      return;
    }
    if (msg?.type === "selection-text") {
      if (typeof msg.text === "string" && msg.text.length) {
        applySelectionText(msg.text);
      }
      return;
    }
    if (msg?.type === "rewrite-soft-feedback") {
      const records = Array.isArray(msg.records) ? msg.records : [];
      if (records.length) {
        window.softFeedbackLog = records;
        console.info("Pronoun soft-feedback records:", records);
      }
      return;
    }

    if (msg?.type === "rewrite-done") {
      const output = typeof msg.output === "string" ? msg.output.trim() : "";
      setRewriteLoadingState(false);
      openSuggestionsTab();
      if (msg.error) {
        renderError(output);
      } else {
        const suggestions = buildSuggestions(output);
        if (suggestions.length) {
          renderSuggestions(suggestions);
          saveSuggestionsSnapshot({
            suggestions,
            sourceText: inputField?.value?.trim() || "",
            storedAt: Date.now(),
          });
        } else {
          renderError(output || "No response.");
        }
      }
      return;
    }
  };

  // auto-load key when opening settings
  tabs.settings.tab.addEventListener("click", ()=> {
    postToPlugin({ type: "load-key" });
    saveStatus.textContent = "Loading…";
  });

  activate("rewrite");
  updateInputCharCount();
  resizeRewriteInput();
  renderEmptyState();
  postToPlugin({ type: "request-guideline" });
</script>
