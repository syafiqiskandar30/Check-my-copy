<!doctype html>
<meta charset="utf-8" />
<style>
  :root {
    --bg: #fff;
    --muted: #f5f5f7;
    --line: #e6e6e6;
    --primary: #7f56d9;
    --text: #111827;
    --subtle: #6b7280;
  }
  *,
  *::before,
  *::after {
    box-sizing: border-box;
  }
  html,
  body {
    font: 14px/1.4 "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
    margin: 0;
    width: 100%;
    max-width: 100%;
    background: var(--bg);
    color: var(--text);
    overflow-x: hidden;
  }
  .tabs {
    display: flex;
    gap: 6px;
    padding: 4px;
    margin: 12px;
    border-radius: 8px;
    background: rgba(0, 0, 0, 0.05);
  }
  .tab {
    flex: 1;
    text-align: center;
    padding: 9px 16px;
    border-radius: 8px;
    cursor: pointer;
    user-select: none;
    font-family: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
    font-weight: 500;
    font-size: 15px;
    line-height: 18px;
    color: #788494;
    transition: color 0.15s ease, background 0.15s ease, box-shadow 0.15s ease;
  }
  .tab.active {
    background: #fff;
    color: #2d333a;
  }
  .panel {
    padding: 12px;
    display: none;
  }
  .panel.active {
    display: block;
  }
  .rewrite-screen {
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.25s ease;
    pointer-events: none;
  }
  .rewrite-screen.active {
    opacity: 1;
    visibility: visible;
    pointer-events: auto;
  }
  .rewrite-screen[hidden] {
    display: none !important;
  }
  .rewrite-screen.loading-screen {
    display: flex;
  }
  .loading-screen {
    min-height: 320px;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 16px;
    text-align: center;
    padding: 32px 16px;
  }
  .loading-screen p {
    margin: 0;
    font-size: 16px;
    line-height: 22px;
    color: #111827;
    font-weight: 500;
    white-space: pre-line;
  }
  .loading-illustration {
    width: 112px;
    height: 112px;
    border-radius: 50%;
    background: #e3f2ff;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .loading-illustration svg {
    width: 90px;
    height: 90px;
    display: block;
  }
  .back-button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    border: none;
    background: transparent;
    cursor: pointer;
    padding: 4px;
    border-radius: 999px;
  }
  .back-button svg {
    width: 24px;
    height: 24px;
    display: block;
  }
  .back-button:focus-visible {
    outline: 2px solid #7f56d9;
    outline-offset: 2px;
  }
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    border: 0;
  }
  .suggestions-screen {
    padding: 16px 0 16px;
  }
  .suggestions-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 16px;
  }
  .suggestions-header h2 {
    margin: 0;
    color: #000;
    font-size: 18px;
    font-style: normal;
    font-weight: 600;
    line-height: 27px;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .field-header {
    display: flex;
    align-items: flex-end;
    justify-content: space-between;
    margin-bottom: 6px;
  }
  .field-label {
    color: #525b65;
    font-size: 14px;
    line-height: 20px;
    font-weight: 500;
  }
  /* shared input styles */
  textarea,
  input[type="text"] {
    width: 100%;
    padding: 12px;
    border: 1px solid #f5f5f5;
    border-radius: 4px;
    font-family: inherit;
    font-size: 14px;
    box-sizing: border-box;
    transition: border-color 0.15s ease;
  }
  textarea {
    resize: none;
    min-height: 52px;
    overflow-y: hidden;
    margin: 0;
  }
  textarea::placeholder,
  input[type="text"]::placeholder {
    color: #788494;
    line-height: 20px;
  }
  textarea:focus,
  input[type="text"]:focus {
    border-color: #00b0ff;
    outline: none;
  }
  .guideline-status {
    margin: 8px 0 0;
    font-size: 12px;
    color: var(--subtle);
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .guideline-status .status-dot {
    width: 8px;
    height: 8px;
    border-radius: 999px;
    background: #d1d5db;
  }
  .guideline-status.loaded .status-dot {
    background: #34d399;
  }
  .guideline-status.fallback .status-dot {
    background: #fbbf24;
  }
  .guideline-status.error .status-dot {
    background: #f87171;
  }
  .rewrite-btn {
    width: 100%;
    margin-top: 16px;
    padding: 12px;
    border: 0;
    border-radius: 12px;
    background: #00b0ff;
    color: #fff;
    font-weight: 600;
    font-size: 14px;
    line-height: 17px;
    letter-spacing: 1px;
    text-transform: uppercase;
    cursor: pointer;
    text-align: center;
    position: relative;
    overflow: hidden;
  }
  .rewrite-btn:disabled:not(.is-loading) {
    cursor: default;
    opacity: 0.65;
  }
  .rewrite-label,
  .rewrite-shimmer {
    display: block;
    transition: opacity 0.2s ease;
  }
  .rewrite-shimmer {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: linear-gradient(110deg, rgba(255,255,255,0.4), #fff, rgba(255,255,255,0.4));
    background-size: 200% auto;
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    animation: shimmerText 1.4s linear infinite;
    font-weight: 700;
    letter-spacing: 0.08em;
    opacity: 0;
    pointer-events: none;
  }
  .rewrite-btn.is-loading .rewrite-label {
    opacity: 0;
  }
  .rewrite-btn.is-loading .rewrite-shimmer {
    opacity: 1;
  }
  @keyframes shimmerText {
    0% {
      background-position: -100% 0;
    }
    100% {
      background-position: 200% 0;
    }
  }
  .suggestions {
    margin-top: 0;
    border: 0;
    padding-top: 0;
  }
  .suggestion-body {
    min-height: 0;
    padding: 0;
    color: var(--subtle);
    display: flex;
    flex-direction: column;
    gap: 10px;
  }
  .suggestion-note {
    border-radius: 10px;
    border: 1px solid #fde1c3;
    background: #fff8f1;
    color: #9a3412;
    font-size: 13px;
    line-height: 18px;
    padding: 10px 12px;
  }
  .suggestion-body.centered {
    padding: 16px;
    min-height: 140px;
    justify-content: center;
    align-items: center;
    text-align: center;
    border-radius: 12px;
    background: var(--muted);
  }
  .suggestion-body.error {
    background: #fef2f2;
    color: #991b1b;
    border: 1px solid #fecaca;
  }
  .suggestion-body.centered .empty-arrow {
    font-size: 30px;
    color: #d1d5db;
  }
  .suggestions-list {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }
  .suggestion-card {
    border-radius: 12px;
    border: 1px solid #f1f1f3;
    background: #f8f8fa;
    padding: 12px 14px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    color: #1f2933;
    transition: opacity 0.3s ease, transform 0.3s ease;
    cursor: default;
  }
  .suggestion-card p {
    margin: 0;
    font-size: 14px;
  }
  .suggestion-meta {
    display: flex;
    align-items: flex-start;
    gap: 4px;
    align-self: stretch;
    color: #788494;
    font-family: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
    font-size: 14px;
    font-style: normal;
    font-weight: 400;
    line-height: 20px;
  }
  .suggestion-card.is-interactive {
    cursor: pointer;
  }
  .suggestion-card.is-interactive:focus-visible {
    outline: 2px solid #00b0ff;
    outline-offset: 2px;
  }
  .suggestion-card.is-interactive:active {
    transform: translateY(1px);
  }
  .suggestions-list.is-loading .suggestion-card {
    opacity: 1;
  }
  .suggestion-card.skeleton {
    position: relative;
    overflow: hidden;
  }
  .suggestion-card.revealing {
    opacity: 0;
    transform: translateY(8px);
  }
  .suggestion-card.revealed {
    opacity: 1;
    transform: translateY(0);
  }
  .skeleton-block {
    background: #e0e0e0;
    position: relative;
    overflow: hidden;
    display: block;
  }
  .skeleton-block::before {
    content: "";
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(
      90deg,
      transparent 0%,
      rgba(255, 255, 255, 0.6) 50%,
      transparent 100%
    );
    animation: shimmer 1.5s infinite;
  }
  @keyframes shimmer {
    0% {
      left: -100%;
    }
    100% {
      left: 100%;
    }
  }
  .skeleton-line,
  .skeleton-pill {
    display: block;
    width: 100%;
    border-radius: 999px;
  }
  .skeleton-line {
    height: 12px;
    margin-bottom: 8px;
  }
  .skeleton-line.long {
    width: 90%;
  }
  .skeleton-line.short {
    width: 55%;
  }
  .skeleton-pill {
    height: 10px;
    width: 72px;
  }
  .skeleton-pill.short {
    width: 42px;
  }
  .skeleton-meta {
    display: flex;
    gap: 8px;
    align-items: center;
    margin-top: 6px;
  }
  @media (prefers-reduced-motion: reduce) {
    .skeleton-block::before {
      animation: none;
    }
  }
  .score-pill {
    background: #d1fae5;
    color: #0f5132;
    border-radius: 6px;
    padding: 2px 8px;
    font-weight: 600;
    font-size: 12px;
  }
  .row {
    display: flex;
    gap: 8px;
    align-items: center;
  }
  .status-text {
    margin-top: 8px;
    font-size: 12px;
    color: var(--subtle);
  }
  .muted-text {
    font-size: 12px;
    color: var(--subtle);
  }
  .context-field {
    margin-top: 24px;
  }
  .context-field label {
    display: block;
    margin-bottom: 8px;
    font-size: 14px;
    line-height: 20px;
    font-weight: 500;
    color: #525b65;
  }
  .context-area {
    width: 100%;
    border: 1px solid #f5f5f5;
    border-radius: 4px;
    background: #fff;
    padding: 12px;
    font-size: 14px;
    line-height: 20px;
    font-family: inherit;
    resize: none;
  }
  .context-area::placeholder {
    color: #94a3b8;
  }
  .length-row {
    margin-top: 16px;
    display: flex;
    flex-direction: column;
    gap: 6px;
  }
  .length-label-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
  }
  .length-label-row label {
    font-size: 14px;
    line-height: 20px;
    font-weight: 500;
    color: #525b65;
  }
  .length-range {
    font-size: 12px;
    color: #94a3b8;
  }
  .length-select {
    width: 100%;
    border: 1px solid #f5f5f5;
    border-radius: 6px;
    padding: 10px 12px;
    font-size: 14px;
    font-family: inherit;
    background: #fff;
    color: #1f2933;
  }
  .length-hint {
    margin: 0;
    font-size: 12px;
    color: #94a3b8;
    line-height: 18px;
  }
  .element-row {
    margin-top: 12px;
    display: flex;
    flex-direction: column;
    gap: 6px;
  }
  .element-label-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
  }
  .element-label-row label {
    font-size: 14px;
    line-height: 20px;
    font-weight: 500;
    color: #525b65;
  }
  .element-hint {
    margin: 0;
    font-size: 12px;
    color: #94a3b8;
    line-height: 18px;
  }
  .keyword-section {
    margin-top: 20px;
    display: flex;
    flex-direction: column;
    gap: 16px;
  }
  .keyword-field label {
    display: block;
    font-size: 14px;
    line-height: 20px;
    font-weight: 500;
    color: #525b65;
  }
  .keyword-label-row {
    display: flex;
    align-items: baseline;
    justify-content: space-between;
    gap: 8px;
    margin-bottom: 6px;
  }
  .keyword-hint {
    font-size: 12px;
    color: #94a3b8;
    margin: 0;
  }
  .chip-input {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    padding: 8px;
    border-radius: 8px;
    border: 1px solid #f5f5f5;
    background: #fff;
    min-height: 48px;
  }
  .chip-list {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
  }
  .chip-input input {
    border: none;
    flex: 1 1 140px;
    min-width: 120px;
    font-size: 14px;
    padding: 6px 4px;
    font-family: inherit;
    color: #1f2933;
  }
  .chip-input input:focus {
    outline: none;
  }
  .keyword-chip {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 4px 8px;
    border-radius: 999px;
    background: #eef2ff;
    color: #1f2933;
    font-size: 13px;
    line-height: 18px;
  }
  .keyword-chip button {
    border: none;
    background: transparent;
    color: #6b7280;
    font-size: 14px;
    cursor: pointer;
    padding: 0;
    line-height: 1;
  }
  .keyword-chip button:focus-visible {
    outline: 2px solid #00b0ff;
    outline-offset: 2px;
  }
  .char-counter {
    font-size: 12px;
    line-height: 18px;
    color: #788494;
  }
</style>

<div class="tabs">
  <div id="tab-rewrite" class="tab active">Rewrite</div>
  <div id="tab-settings" class="tab">Settings</div>
</div>

<div id="panel-rewrite" class="panel active">
  <div class="rewrite-screen-container">
    <div id="rewriteHome" class="rewrite-screen active">
      <div class="field-header">
        <label id="inputLabel" class="field-label" for="inputText">Enter copy</label>
        <div id="inputCharCount" class="char-counter">0 characters</div>
      </div>
      <textarea
        id="inputText"
        class="auto-textarea"
        rows="2"
        placeholder="Type your copy or select a text layer in figma"
      ></textarea>
      <!-- tone controls removed -->
      <div class="context-field">
        <label for="usageContextInput">Context and custom instructions</label>
        <textarea
          id="usageContextInput"
          class="context-area auto-textarea"
          rows="2"
          placeholder="Use on fuelling flow.&#10;Do not use word &ldquo;free&rdquo;."
        ></textarea>
      </div>
      <div class="length-row">
        <div class="length-label-row">
          <label for="lengthSelect">Target length</label>
          <span id="lengthRangeLabel" class="length-range">Auto mix</span>
        </div>
        <select id="lengthSelect" class="length-select">
          <option value="">Auto (mix short + medium + long)</option>
        </select>
        <p id="lengthHint" class="length-hint">We'll mix short, medium, and long suggestions automatically.</p>
      </div>
      <div class="element-row">
        <div class="element-label-row">
          <label for="elementSelect">Element</label>
          <span id="elementLabel" class="length-range">All elements</span>
        </div>
        <select id="elementSelect" class="length-select">
          <option value="">All elements (library hints included)</option>
        </select>
        <p id="elementHint" class="element-hint">
          Use the sentence library above to guide tone and structure for each element.
        </p>
      </div>
      <div class="keyword-section">
        <div class="keyword-field">
          <div class="keyword-label-row">
            <label for="requiredKeywordInput">Must-include phrases</label>
            <p class="keyword-hint">Press Enter to add</p>
          </div>
          <div class="chip-input" data-field="required">
            <div id="requiredKeywordChips" class="chip-list"></div>
            <input
              id="requiredKeywordInput"
              type="text"
              placeholder="Add keyword or phrase"
              autocomplete="off"
            />
          </div>
        </div>
        <div class="keyword-field">
          <div class="keyword-label-row">
            <label for="avoidKeywordInput">Avoid phrases</label>
            <p class="keyword-hint">Press Enter to add</p>
          </div>
          <div class="chip-input" data-field="avoid">
            <div id="avoidKeywordChips" class="chip-list"></div>
            <input
              id="avoidKeywordInput"
              type="text"
              placeholder="Add banned word or phrase"
              autocomplete="off"
            />
          </div>
        </div>
      </div>

      <button id="rewrite" class="rewrite-btn" disabled aria-live="polite">
        <span class="rewrite-label">Rewrite</span>
        <span id="rewriteShimmerText" class="rewrite-shimmer" aria-hidden="true">Crafting copy…</span>
      </button>
    </div>

    <div id="suggestionsScreen" class="rewrite-screen suggestions-screen" hidden>
      <div class="suggestions-header">
        <button type="button" id="backToForm" class="back-button" aria-label="Back to rewrite form">
          <span class="sr-only">Back</span>
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
            <path d="M15.5303 4.46967C15.2641 4.2034 14.8474 4.1792 14.5538 4.39705L14.4697 4.46967L7.46967 11.4697C7.2034 11.7359 7.1792 12.1526 7.39705 12.4462L7.46967 12.5303L14.4697 19.5303C14.7626 19.8232 15.2374 19.8232 15.5303 19.5303C15.7966 19.2641 15.8208 18.8474 15.6029 18.5538L15.5303 18.4697L9.061 12L15.5303 5.53033C15.7966 5.26406 15.8208 4.8474 15.6029 4.55379L15.5303 4.46967Z" fill="#2d333a"/>
          </svg>
        </button>
        <h2>Suggestions</h2>
      </div>
      <section class="suggestions">
        <div id="suggestionBody" class="suggestion-body centered"></div>
      </section>
    </div>
  </div>
</div>

<div id="panel-settings" class="panel">
  <div id="guidelineStatus" class="guideline-status fallback">
    <span class="status-dot"></span>
    <span class="guideline-text">Loading style guide…</span>
  </div>
  <label>API key (Gemini)</label>
  <input id="apikey" type="text" placeholder="AIza..." />
  <div class="row">
    <button id="saveKey">Save key</button>
    <button id="loadKey">Load key</button>
  </div>
  <div id="saveStatus" style="margin-top:8px;color:#555;"></div>
</div>

<script>
  // tab switching
  const tabs = {
    rewrite: { tab: document.getElementById("tab-rewrite"), panel: document.getElementById("panel-rewrite") },
    settings:{ tab: document.getElementById("tab-settings"), panel: document.getElementById("panel-settings") },
  };
  function activate(name){
    Object.values(tabs).forEach(({tab,panel})=>{
      tab.classList.remove("active"); panel.classList.remove("active");
    });
    tabs[name].tab.classList.add("active"); tabs[name].panel.classList.add("active");
  }
  tabs.rewrite.tab.onclick=()=>activate("rewrite");
  tabs.settings.tab.onclick=()=>{
    activate("settings");
  };

  // rewrite flow
  const btnRewrite = document.getElementById("rewrite");
  const suggestionBody = document.getElementById("suggestionBody");
  const rewriteHomeScreen = document.getElementById("rewriteHome");
  const suggestionsScreen = document.getElementById("suggestionsScreen");
  const backToFormBtn = document.getElementById("backToForm");
  const rewriteShimmerText = document.getElementById("rewriteShimmerText");
  const screenViews = {
    home: rewriteHomeScreen,
    suggestions: suggestionsScreen,
  };
  const SCREEN_FADE_MS = 250;
  const viewHideTimers = new WeakMap();
  const cancelPendingHide = (view) => {
    const timerId = viewHideTimers.get(view);
    if (timerId) {
      clearTimeout(timerId);
      viewHideTimers.delete(view);
    }
  };
  const scheduleHide = (view) => {
    if (!view) return;
    cancelPendingHide(view);
    const timerId = setTimeout(() => {
      if (!view.classList.contains("active")) {
        view.hidden = true;
      }
      viewHideTimers.delete(view);
    }, SCREEN_FADE_MS + 75);
    viewHideTimers.set(view, timerId);
  };
  const scrollToTop = () => {
    if (typeof window === "undefined") return;
    requestAnimationFrame(() => {
      const scroller = document.scrollingElement || document.documentElement || document.body;
      if (scroller) {
        scroller.scrollTop = 0;
      }
      if (typeof window.scrollTo === "function") {
        window.scrollTo(0, 0);
      }
    });
  };
  const showScreen = (name) => {
    const target = screenViews[name];
    if (!target) return;
    if (target.classList.contains("active")) return;
    Object.entries(screenViews).forEach(([key, view]) => {
      if (!view) return;
      const isActive = key === name;
      if (isActive) {
        cancelPendingHide(view);
        view.hidden = false;
        requestAnimationFrame(() => view.classList.add("active"));
      } else if (view.classList.contains("active")) {
        view.classList.remove("active");
        scheduleHide(view);
      } else {
        view.classList.remove("active");
        view.hidden = true;
      }
    });
    if (name === "suggestions" || name === "home") {
      scrollToTop();
    }
  };
  const showHomeScreen = () => showScreen("home");
  const showSuggestionsScreen = () => showScreen("suggestions");
  backToFormBtn?.addEventListener("click", () => {
    showHomeScreen();
  });
  showHomeScreen();
  const inputField = document.getElementById("inputText");
  const inputLabelEl = document.getElementById("inputLabel");
  const inputCharCounter = document.getElementById("inputCharCount");
  const lengthSelect = document.getElementById("lengthSelect");
  const lengthRangeLabel = document.getElementById("lengthRangeLabel");
  const lengthHintEl = document.getElementById("lengthHint");
  const elementSelect = document.getElementById("elementSelect");
  const elementLabel = document.getElementById("elementLabel");
  const elementHintEl = document.getElementById("elementHint");
  const MIN_SUGGESTIONS = 5;
  const SUGGESTION_STORAGE_KEY = "setel.rewrite.lastSuggestions";
  const toneFallbacks = [
    ["Friendly", "Caring"],
    ["Professional", "Clear"],
    ["Empathetic", "Supportive"],
    ["Persuasive", "Action-focused"],
    ["Playful", "Upbeat"],
    ["Inspirational", "Motivating"],
    ["Neutral", "Informative"],
    ["Urgent", "Time-sensitive"],
    ["Exclusive", "Premium"],
    ["Technical", "Precise"],
  ];
  const MIN_INPUT_HEIGHT = 52;
  const rewriteLabelEl = document.querySelector(".rewrite-label");
  const MODE_REWRITE = "rewrite";
  const generationMode = MODE_REWRITE;
  const MODE_CONFIG = {
    label: "Enter copy",
    placeholder: "Paste copy or select a text layer in Figma",
    buttonLabel: "Rewrite",
    loadingText: "Crafting copy…",
  };
  let rewriteInProgress = false;
  const getModeConfig = () => MODE_CONFIG;
  const updateModeUI = () => {
    const config = getModeConfig();
    if (inputLabelEl) inputLabelEl.textContent = config.label;
    if (inputField && !inputField.value.trim()) {
      inputField.placeholder = config.placeholder;
    }
    if (rewriteLabelEl) rewriteLabelEl.textContent = config.buttonLabel;
    if (!rewriteInProgress && rewriteShimmerText) {
      rewriteShimmerText.textContent = config.loadingText;
    }
  };
  updateModeUI();
  const getModeLoadingText = () => getModeConfig().loadingText;
  const updateRewriteButtonState = () => {
    if (!btnRewrite) return;
    if (rewriteInProgress) {
      btnRewrite.disabled = true;
      return;
    }
    const hasText = Boolean(inputField?.value.trim());
    btnRewrite.disabled = !hasText;
  };
  const setRewriteLoadingState = (isLoading, text) => {
    rewriteInProgress = Boolean(isLoading);
    if (btnRewrite) {
      btnRewrite.classList.toggle("is-loading", rewriteInProgress);
      btnRewrite.setAttribute("aria-busy", rewriteInProgress ? "true" : "false");
    }
    const labelText = typeof text === "string" && text.trim() ? text : getModeLoadingText();
    if (rewriteShimmerText) {
      rewriteShimmerText.textContent = labelText;
    }
    if (!rewriteInProgress) {
      updateModeUI();
    }
    updateRewriteButtonState();
  };
  const autoResizeTextarea = (element, minHeight = MIN_INPUT_HEIGHT) => {
    if (!element) return;
    element.style.height = "auto";
    const nextHeight = Math.max(element.scrollHeight, minHeight);
    element.style.height = `${nextHeight}px`;
  };
  const resizeRewriteInput = () => {
    autoResizeTextarea(inputField, MIN_INPUT_HEIGHT);
  };

  const geminiKeyInput = document.getElementById("apikey");
  const saveKeyBtn = document.getElementById("saveKey");
  const loadKeyBtn = document.getElementById("loadKey");
  const saveStatus = document.getElementById("saveStatus");
  const guidelineStatus = document.getElementById("guidelineStatus");
  const guidelineStatusText = guidelineStatus?.querySelector(".guideline-text");
  const usageContextInput = document.getElementById("usageContextInput");
  const MIN_CONTEXT_HEIGHT = 72;
  const CONTEXT_LINE_HEIGHT = 20;
  const CONTEXT_VERTICAL_PADDING = 24;
  const DEFAULT_CONTEXT_PLACEHOLDER = "";
  const DEFAULT_PLACEHOLDER_LINES = 1;
  let contextPlaceholderSizer = null;
  const updateContextPlaceholder = (text, lineCount = DEFAULT_PLACEHOLDER_LINES) => {
    if (!usageContextInput) return;
    usageContextInput.placeholder = text;
    const totalLines = Math.max(lineCount, DEFAULT_PLACEHOLDER_LINES);
    let minHeight = Math.max(
      MIN_CONTEXT_HEIGHT,
      CONTEXT_VERTICAL_PADDING + totalLines * CONTEXT_LINE_HEIGHT
    );
    if (!contextPlaceholderSizer) {
      contextPlaceholderSizer = document.createElement("div");
      contextPlaceholderSizer.setAttribute("aria-hidden", "true");
      contextPlaceholderSizer.style.position = "absolute";
      contextPlaceholderSizer.style.visibility = "hidden";
      contextPlaceholderSizer.style.whiteSpace = "pre-wrap";
      contextPlaceholderSizer.style.wordBreak = "break-word";
      contextPlaceholderSizer.style.top = "-9999px";
      contextPlaceholderSizer.style.left = "-9999px";
      contextPlaceholderSizer.style.pointerEvents = "none";
      contextPlaceholderSizer.style.boxSizing = "border-box";
      document.body.appendChild(contextPlaceholderSizer);
    }
    const computed = getComputedStyle(usageContextInput);
    contextPlaceholderSizer.style.font = computed.font || "";
    contextPlaceholderSizer.style.lineHeight = computed.lineHeight || "";
    contextPlaceholderSizer.style.padding = computed.padding || "";
    contextPlaceholderSizer.style.width = `${usageContextInput.clientWidth}px`;
    contextPlaceholderSizer.textContent = text;
    const measuredHeight = contextPlaceholderSizer.scrollHeight;
    minHeight = Math.max(minHeight, measuredHeight);
    usageContextInput.style.minHeight = `${minHeight}px`;
    if (!usageContextInput.value.trim().length) {
      usageContextInput.style.height = `${minHeight}px`;
    }
  };
  if (usageContextInput) {
    updateContextPlaceholder(DEFAULT_CONTEXT_PLACEHOLDER, DEFAULT_PLACEHOLDER_LINES);
  }
  const resizeContextInput = () => {
    autoResizeTextarea(usageContextInput, MIN_CONTEXT_HEIGHT);
  };
  let usageContextValue = "";
  const requiredKeywordInput = document.getElementById("requiredKeywordInput");
  const avoidKeywordInput = document.getElementById("avoidKeywordInput");
  const requiredKeywordChips = document.getElementById("requiredKeywordChips");
  const avoidKeywordChips = document.getElementById("avoidKeywordChips");
  const manualKeywordState = {
    required: [],
    avoid: [],
  };
  const keywordInputs = {
    required: requiredKeywordInput,
    avoid: avoidKeywordInput,
  };
  const keywordChipLists = {
    required: requiredKeywordChips,
    avoid: avoidKeywordChips,
  };
  const keywordTypes = ["required", "avoid"];
  const sanitizeKeyword = (value = "") => value.replace(/\s+/g, " ").trim();
  const renderKeywordChips = (type) => {
    const listEl = keywordChipLists[type];
    if (!listEl) return;
    listEl.innerHTML = "";
    const keywords = manualKeywordState[type] || [];
    keywords.forEach((keyword, index) => {
      const chip = document.createElement("span");
      chip.className = "keyword-chip";
      const label = document.createElement("span");
      label.textContent = keyword;
      const removeBtn = document.createElement("button");
      removeBtn.type = "button";
      removeBtn.className = "chip-remove";
      removeBtn.setAttribute("aria-label", `Remove keyword "${keyword}"`);
      removeBtn.textContent = "×";
      removeBtn.addEventListener("click", () => {
        manualKeywordState[type].splice(index, 1);
        renderKeywordChips(type);
      });
      chip.appendChild(label);
      chip.appendChild(removeBtn);
      listEl.appendChild(chip);
    });
  };
  const addManualKeyword = (type, rawValue) => {
    const keyword = sanitizeKeyword(rawValue);
    if (!keyword) return false;
    const keywords = manualKeywordState[type];
    const exists = keywords.some((value) => value.toLowerCase() === keyword.toLowerCase());
    if (exists) return false;
    keywords.push(keyword);
    renderKeywordChips(type);
    return true;
  };
  const commitManualKeywordFromInput = (type) => {
    const input = keywordInputs[type];
    if (!input) return;
    if (addManualKeyword(type, input.value)) {
      input.value = "";
    }
  };
  const commitAllManualKeywords = () => {
    keywordTypes.forEach((type) => commitManualKeywordFromInput(type));
  };
  const handleKeywordInputKeydown = (event, type) => {
    if (!event) return;
    if (event.key === "Enter" || event.key === ",") {
      event.preventDefault();
      commitManualKeywordFromInput(type);
      return;
    }
    if (
      event.key === "Backspace" &&
      event.target instanceof HTMLInputElement &&
      !event.target.value.trim() &&
      manualKeywordState[type].length
    ) {
      manualKeywordState[type].pop();
      renderKeywordChips(type);
      event.preventDefault();
    }
  };
  keywordTypes.forEach((type) => {
    const input = keywordInputs[type];
    if (!input) return;
    input.addEventListener("keydown", (event) => handleKeywordInputKeydown(event, type));
    input.addEventListener("blur", () => commitManualKeywordFromInput(type));
  });
  const formatCharCount = (count) => `${count} character${count === 1 ? "" : "s"}`;
  const updateInputCharCount = () => {
    if (!inputCharCounter) return;
    const value = inputField?.value || "";
    inputCharCounter.textContent = formatCharCount(value.length);
  };
  const SUGGESTION_INITIAL_DELAY = 320;
  const SUGGESTION_REVEAL_STEP = 180;
  const SKELETON_MIN_DISPLAY_MS = 1100;
  let suggestionRevealTimers = [];
  let skeletonVisibleSince = 0;
  let skeletonActive = false;
  const reducedMotionQuery =
    typeof window !== "undefined" && window.matchMedia
      ? window.matchMedia("(prefers-reduced-motion: reduce)")
      : null;
  const prefersReducedMotion = () => Boolean(reducedMotionQuery?.matches);
  const clearSuggestionRevealTimers = () => {
    suggestionRevealTimers.forEach((timerId) => clearTimeout(timerId));
    suggestionRevealTimers = [];
    skeletonVisibleSince = 0;
    skeletonActive = false;
  };
  const resetSuggestionCardInteractivity = (card) => {
    if (!card) return;
    card.classList.remove("is-interactive", "revealed");
    card.removeAttribute("role");
    card.removeAttribute("tabindex");
    card.removeAttribute("data-text");
  };
  const createSkeletonCardElement = () => {
    const card = document.createElement("article");
    card.className = "suggestion-card skeleton";
    resetSuggestionCardInteractivity(card);
    card.innerHTML = `
      <div class="skeleton-line skeleton-block long"></div>
      <div class="skeleton-line skeleton-block"></div>
      <div class="skeleton-line skeleton-block short"></div>
      <div class="skeleton-meta">
        <span class="skeleton-pill skeleton-block"></span>
        <span class="skeleton-pill skeleton-block short"></span>
        <span class="skeleton-pill skeleton-block"></span>
      </div>
    `;
    return card;
  };
  const renderSkeletonPlaceholders = (count = MIN_SUGGESTIONS) => {
    if (!suggestionBody) return { list: null, cards: [] };
    clearSuggestionRevealTimers();
    suggestionBody.className = "suggestion-body";
    suggestionBody.innerHTML = "";
    const list = document.createElement("div");
    list.className = "suggestions-list is-loading";
    suggestionBody.appendChild(list);
    const total = Math.max(1, Number(count) || 0);
    const cards = [];
    for (let i = 0; i < total; i += 1) {
      const card = createSkeletonCardElement();
      list.appendChild(card);
      cards.push(card);
    }
    skeletonVisibleSince =
      typeof performance !== "undefined" && performance.now ? performance.now() : Date.now();
    skeletonActive = true;
    return { list, cards };
  };
  const revealCardContent = (card, item) => {
    if (!card) return;
    card.classList.remove("skeleton");
    card.dataset.text = item.text;
    card.innerHTML = `
      <p>${item.text}</p>
      <div class="suggestion-meta">
        <span class="suggestion-char">${formatCharCount(item.charCount ?? item.text.length)}</span>
      </div>
    `;
    card.setAttribute("role", "button");
    card.tabIndex = 0;
    card.classList.add("is-interactive");
    card.addEventListener("click", handleSuggestionCardClick);
    card.addEventListener("keydown", handleSuggestionCardKeydown);
    card.classList.add("revealing");
    requestAnimationFrame(() => {
      card.classList.remove("revealing");
      card.classList.add("revealed");
    });
  };
  const scheduleSuggestionReveal = (cards, items, list) => {
    if (!cards.length || !items.length) return;
    const baseDelay = prefersReducedMotion() ? 0 : SUGGESTION_INITIAL_DELAY;
    const stepDelay = prefersReducedMotion() ? 0 : SUGGESTION_REVEAL_STEP;
    cards.forEach((card, idx) => {
      const now = typeof performance !== "undefined" && performance.now ? performance.now() : Date.now();
      const elapsed = Math.max(0, now - skeletonVisibleSince);
      const minVisibleOffset =
        skeletonActive && !prefersReducedMotion()
          ? Math.max(SKELETON_MIN_DISPLAY_MS - elapsed, 0)
          : 0;
      const timer = setTimeout(() => {
        revealCardContent(card, items[idx]);
        if (idx === cards.length - 1 && list) {
          list.classList.remove("is-loading");
          skeletonActive = false;
          skeletonVisibleSince = 0;
        }
      }, baseDelay + idx * stepDelay + minVisibleOffset);
      suggestionRevealTimers.push(timer);
    });
  };

  const fallbackGuideline = Object.freeze({
    name: "Warm lower-case headings",
    instructions:
      "Write 2-6 word lower-case headings with a warm, appreciative, enthusiastic tone. Keep copy mobile friendly and avoid emojis unless explicitly requested.",
    examples: [
      "thanks for being here",
      "we love having you",
      "you're in great company",
    ],
  });

  const guidelineMeta = {
    rewriteOverview: "",
    rewriteRequirements: [],
  };
  const defaultLengthGuide = {
    overview: "We'll automatically mix short (0-32), medium (33-72), and long (73-140) unless you pick a target.",
    options: {
      short: {
        label: "Short",
        min_chars: 0,
        max_chars: 32,
        range_hint: "0-32 characters",
        structure: "2-5 words. Verb + noun/object. No filler.",
        use_cases: ["Primary buttons", "Badges/chips", "Toast titles"],
        notes: "Still state the action clearly.",
      },
      medium: {
        label: "Medium",
        min_chars: 33,
        max_chars: 72,
        range_hint: "33-72 characters",
        structure: "1 sentence. Verb + benefit + helper clause.",
        use_cases: ["Push notifications", "Modals", "List tiles"],
        notes: "Add context first, then action. Avoid small talk.",
      },
      long: {
        label: "Long",
        min_chars: 73,
        max_chars: 140,
        range_hint: "73-140 characters",
        structure: "1-2 sentences. Outcome first, action second.",
        use_cases: ["Empty states", "Education cards", "Tooltips"],
        notes: "Max two sentences so it stays scannable.",
      },
    },
  };
  const cleanString = (value) => (typeof value === "string" ? value.trim() : "");
  const toNumberOrUndefined = (value) =>
    typeof value === "number" && Number.isFinite(value) ? value : undefined;
  const formatRangeLabel = (min, max, fallback) => {
    if (cleanString(fallback)) return cleanString(fallback);
    const hasMin = typeof min === "number";
    const hasMax = typeof max === "number";
    if (hasMin && hasMax) return `${min}-${max} characters`;
    if (hasMax) return `≤${max} characters`;
    if (hasMin) return `≥${min} characters`;
    return "";
  };
  const normalizeLengthGuide = (guide) => {
    const source = guide?.length_presets || guide || {};
    const overview = cleanString(source.overview);
    const options = [];
    const entries = source.options && typeof source.options === "object" ? source.options : {};
    Object.entries(entries).forEach(([id, spec]) => {
      if (!spec || typeof spec !== "object") return;
      const label = cleanString(spec.label) || cleanString(id);
      if (!label) return;
      const minChars = toNumberOrUndefined(spec.min_chars);
      const maxChars = toNumberOrUndefined(spec.max_chars);
      const rangeLabel = formatRangeLabel(minChars, maxChars, spec.range_hint);
      const structure = cleanString(spec.structure);
      const useCases = Array.isArray(spec.use_cases)
        ? spec.use_cases
            .map((entry) => cleanString(entry))
            .filter(Boolean)
        : [];
      const useCasesText = useCases.length ? `Use for: ${useCases.join(", ")}.` : "";
      const notes = cleanString(spec.notes);
      const summaryParts = [structure, useCasesText, notes].filter(Boolean);
      options.push({
        id,
        label,
        minChars,
        maxChars,
        rangeLabel,
        structure,
        useCasesText,
        notes,
        summary: summaryParts.join(" "),
      });
    });
    return {
      overview,
      options,
    };
  };
  const initialLengthState = normalizeLengthGuide(defaultLengthGuide);
  let lengthPresets = initialLengthState.options;
  let lengthOverviewText = initialLengthState.overview;
  let selectedLengthId = "";
  const getLengthPresetById = (value) => lengthPresets.find((preset) => preset.id === value);
  const updateLengthDisplays = () => {
    const activePreset = selectedLengthId ? getLengthPresetById(selectedLengthId) : null;
    if (lengthRangeLabel) {
      lengthRangeLabel.textContent = activePreset ? activePreset.rangeLabel : "Auto mix";
    }
    if (lengthHintEl) {
      if (activePreset) {
        lengthHintEl.textContent = activePreset.summary || lengthOverviewText;
      } else {
        const rangeSummary = lengthPresets
          .map((preset) => `${preset.label} ${preset.rangeLabel}`.trim())
          .filter(Boolean)
          .join(", ");
        const base = lengthOverviewText || "We'll mix short, medium, and long suggestions automatically.";
        lengthHintEl.textContent = rangeSummary ? `${base} (${rangeSummary}).` : base;
      }
    }
  };
  const renderLengthSelectOptions = () => {
    if (!lengthSelect) return;
    const previous = lengthSelect.value;
    lengthSelect.innerHTML = "";
    const autoOption = document.createElement("option");
    autoOption.value = "";
    autoOption.textContent = "Auto (mix short + medium + long)";
    lengthSelect.appendChild(autoOption);
    lengthPresets.forEach((preset) => {
      const option = document.createElement("option");
      option.value = preset.id;
      option.textContent = `${preset.label} (${preset.rangeLabel || "range"})`;
      lengthSelect.appendChild(option);
    });
    const validPrevious = previous && getLengthPresetById(previous) ? previous : "";
    lengthSelect.value = validPrevious;
    selectedLengthId = validPrevious;
    updateLengthDisplays();
  };
  const applyLengthGuide = (guide) => {
    const normalized = normalizeLengthGuide(guide?.length_presets ? guide : defaultLengthGuide);
    if (normalized.options.length) {
      lengthPresets = normalized.options;
      lengthOverviewText = normalized.overview || defaultLengthGuide.overview;
    } else {
      const fallback = normalizeLengthGuide(defaultLengthGuide);
      lengthPresets = fallback.options;
      lengthOverviewText = fallback.overview;
    }
    if (!getLengthPresetById(selectedLengthId)) {
      selectedLengthId = "";
    }
    renderLengthSelectOptions();
  };
  renderLengthSelectOptions();
  lengthSelect?.addEventListener("change", () => {
    selectedLengthId = lengthSelect.value || "";
    updateLengthDisplays();
  });

  const makeElementLabel = (value) => {
    const cleaned = cleanString(value);
    if (!cleaned) return "";
    return cleaned
      .split(/[_\s]+/g)
      .filter(Boolean)
      .map((segment) => {
        const lower = segment.toLowerCase();
        return lower.charAt(0).toUpperCase() + lower.slice(1);
      })
      .join(" ");
  };
  const normalizeSentenceLibrary = (guide) => {
    const entries =
      guide && typeof guide === "object" && guide.sentence_library && typeof guide.sentence_library === "object"
        ? guide.sentence_library.elements
        : null;
    const options = [];
    if (entries && typeof entries === "object") {
      Object.entries(entries).forEach(([id, spec]) => {
        if (!Array.isArray(spec)) return;
        const label = makeElementLabel(id) || cleanString(id);
        if (!label) return;
        const hints = spec
          .map((item) => {
            if (!item || typeof item !== "object") return "";
            const example = cleanString(item.example);
            if (!example) return "";
            const why = cleanString(item.why);
            return why ? `${example} (${why})` : example;
          })
          .filter(Boolean);
        if (!hints.length) return;
        options.push({
          id,
          label,
          hint: hints[0],
          extras: hints.slice(1),
        });
      });
    }
    return {
      options,
    };
  };
  let sentenceLibraryOptions = [];
  let selectedElementId = "";
  const getElementOptionById = (value) => sentenceLibraryOptions.find((option) => option.id === value);
  const updateElementDisplays = () => {
    const active = selectedElementId ? getElementOptionById(selectedElementId) : null;
    if (elementLabel) {
      elementLabel.textContent = active ? active.label : "All elements";
    }
    if (elementHintEl) {
      if (active) {
        elementHintEl.textContent = active.hint;
      } else if (sentenceLibraryOptions.length) {
        elementHintEl.textContent = "Library hints for every element influence the prompt.";
      } else {
        elementHintEl.textContent = "Sentence library examples load once the style guide is ready.";
      }
    }
  };
  const renderElementSelectOptions = () => {
    if (!elementSelect) return;
    const previous = elementSelect.value;
    elementSelect.innerHTML = "";
    const autoOption = document.createElement("option");
    autoOption.value = "";
    autoOption.textContent = "All elements (library hints included)";
    elementSelect.appendChild(autoOption);
    sentenceLibraryOptions.forEach((option) => {
      const opt = document.createElement("option");
      opt.value = option.id;
      opt.textContent = option.label;
      elementSelect.appendChild(opt);
    });
    const validPrevious = previous && getElementOptionById(previous) ? previous : "";
    elementSelect.value = validPrevious;
    selectedElementId = validPrevious;
    updateElementDisplays();
  };
  const applySentenceLibrary = (guide) => {
    const normalized = normalizeSentenceLibrary(guide);
    sentenceLibraryOptions = normalized.options;
    if (!getElementOptionById(selectedElementId)) {
      selectedElementId = "";
    }
    renderElementSelectOptions();
  };
  renderElementSelectOptions();
  elementSelect?.addEventListener("change", () => {
    selectedElementId = elementSelect.value || "";
    updateElementDisplays();
  });

  const shortenHelperText = (text) => {
    const clean = String(text || "").trim();
    if (!clean) return "";
    const withoutLead = clean
      .replace(
        /^(Use|Keep|Explain|Provide|Offer|Make|Add|Focus on|Highlight|Remember|Ensure|Avoid|Encourage|Maintain|Share|Deliver|Emphasize|Support)\b[\s,:-]*/i,
        ""
      )
      .trim();
    const tightened = withoutLead
      .replace(/\b(make sure to|be sure to|try to|aim to|you should|you must)\b/gi, "")
      .replace(/\b(please|really|just)\b/gi, "")
      .replace(/\b(your|their)\s+(users?|audience|customers?)\b/gi, "$2")
      .replace(/\s{2,}/g, " ")
      .trim();
    const candidate = tightened || withoutLead || clean;
    return candidate.replace(/[.:;]+$/, "").trim();
  };

  const updateContextHints = () => {
    if (!usageContextInput) return;
    const helperLines = (guidelineMeta.rewriteRequirements || [])
      .map((req) => shortenHelperText(req))
      .filter(Boolean)
      .slice(0, 3);
    if (!helperLines.length) {
      updateContextPlaceholder(DEFAULT_CONTEXT_PLACEHOLDER, DEFAULT_PLACEHOLDER_LINES);
      return;
    }
    updateContextPlaceholder(helperLines.join("\n"), helperLines.length);
  };

  const applyGuidelineMeta = (guide) => {
    const rewritePrompt = guide?.rewritePrompt || {};
    guidelineMeta.rewriteOverview =
      typeof rewritePrompt.overview === "string" ? rewritePrompt.overview.trim() : "";
    guidelineMeta.rewriteRequirements = Array.isArray(rewritePrompt.requirements)
      ? rewritePrompt.requirements
          .map((item) => (typeof item === "string" ? item.trim() : ""))
          .filter(Boolean)
      : [];
    applyLengthGuide(guide);
    applySentenceLibrary(guide);
    updateContextHints();
  };

  window.addEventListener("resize", () => {
    if (usageContextInput && !usageContextInput.value.trim().length) {
      updateContextHints();
    }
  });

  const setGuidelineIndicator = (state, text) => {
    if (!guidelineStatus || !guidelineStatusText) return;
    guidelineStatus.classList.remove("loaded", "fallback", "error");
    guidelineStatus.classList.add(state);
    guidelineStatusText.textContent = text;
  };

  let guidelineReference = null;
  const getGuidelinePayload = () => {
    if (guidelineReference) return guidelineReference;
    setGuidelineIndicator("fallback", "Using fallback style guide.");
    return fallbackGuideline;
  };
  const buildGuidelinePayload = () => {
    const base = getGuidelinePayload();
    const payload = base && typeof base === "object" ? { ...base } : {};
    delete payload.tonePreference;
    delete payload.styleFilters;
    if (usageContextValue) {
      payload.usageContext = usageContextValue;
    } else {
      delete payload.usageContext;
    }
    const manualRequired = manualKeywordState.required.slice();
    const manualAvoid = manualKeywordState.avoid.slice();
    if (manualRequired.length || manualAvoid.length) {
      const mergeKeywordLists = (existing, additions) => {
        const current = Array.isArray(existing)
          ? existing
              .map((item) => (typeof item === "string" ? item.trim() : ""))
              .filter(Boolean)
          : [];
        const merged = [];
        const seen = new Set();
        current.concat(additions).forEach((value) => {
          const trimmed = sanitizeKeyword(value);
          if (!trimmed) return;
          const key = trimmed.toLowerCase();
          if (seen.has(key)) return;
          seen.add(key);
          merged.push(trimmed);
        });
        return merged;
      };
      const validationSource =
        payload.validation && typeof payload.validation === "object"
          ? { ...payload.validation }
          : {};
      if (manualRequired.length) {
        validationSource.required_phrases = mergeKeywordLists(
          validationSource.required_phrases,
          manualRequired
        );
      }
      if (manualAvoid.length) {
        validationSource.avoid_phrases = mergeKeywordLists(validationSource.avoid_phrases, manualAvoid);
      }
      payload.validation = validationSource;
      payload.manualConstraints = {
        required: manualRequired,
        avoid: manualAvoid,
      };
    }
    const activeElement = selectedElementId ? getElementOptionById(selectedElementId) : null;
    if (activeElement) {
      payload.element_focus = activeElement.id;
    } else if (payload.element_focus) {
      delete payload.element_focus;
    }
    const activeLengthPreset = selectedLengthId ? getLengthPresetById(selectedLengthId) : null;
    if (activeLengthPreset) {
      const lengthPreference = {
        id: activeLengthPreset.id,
        label: activeLengthPreset.label,
        range_hint: activeLengthPreset.rangeLabel,
        structure: activeLengthPreset.structure,
        description: activeLengthPreset.summary,
      };
      if (typeof activeLengthPreset.minChars === "number") {
        lengthPreference.min_chars = activeLengthPreset.minChars;
      }
      if (typeof activeLengthPreset.maxChars === "number") {
        lengthPreference.max_chars = activeLengthPreset.maxChars;
      }
      payload.length_preference = lengthPreference;
    } else if (payload.length_preference) {
      delete payload.length_preference;
    }
    return payload;
  };
  setGuidelineIndicator("fallback", "Loading style guide…");

  const resolveTargetOrigin = () => {
    try {
      const ref = document.referrer;
      if (ref && ref !== "null") {
        return new URL(ref).origin;
      }
    } catch (err) {
      console.warn("Could not parse parent origin:", err);
    }
    return "https://www.figma.com";
  };

  const targetOrigin = resolveTargetOrigin();

  const postToPlugin = (pluginMessage) => {
    if (!window.parent || window.parent === window) {
      console.warn("Figma host unavailable; skipping postMessage", pluginMessage);
      return;
    }
    window.parent.postMessage({ pluginMessage }, targetOrigin);
  };
  const applySuggestionText = (text) => {
    if (typeof text !== "string" || !text.trim()) return;
    if (inputField) {
      inputField.value = text;
      inputField.dispatchEvent(new Event("input"));
    }
    postToPlugin({ type: "apply-text", text });
  };
  const activateSuggestionCard = (target) => {
    const card = target instanceof HTMLElement ? target : null;
    if (!card || card.classList.contains("skeleton")) return;
    const text = card.getAttribute("data-text") || "";
    if (!text.trim()) return;
    applySuggestionText(text);
  };
  const handleSuggestionCardClick = (event) => {
    if (!event?.currentTarget) return;
    event.preventDefault();
    activateSuggestionCard(event.currentTarget);
  };
  const handleSuggestionCardKeydown = (event) => {
    if (!event?.currentTarget) return;
    const key = event.key;
    if (key === "Enter" || key === " ") {
      event.preventDefault();
      activateSuggestionCard(event.currentTarget);
    }
  };

  const renderEmptyState = () => {
    if (restoreSuggestionsFromStorage()) {
      return;
    }
    clearSuggestionRevealTimers();
    suggestionBody.className = "suggestion-body centered";
    suggestionBody.innerHTML = `
      <div class="empty-arrow">↑</div>
      <p>Paste copy to rewrite, then click the button for fresh suggestions.</p>
    `;
  };

  const renderLoading = (text, skeletonCount = MIN_SUGGESTIONS) => {
    showSuggestionsScreen();
    renderSkeletonPlaceholders(skeletonCount);
    const labelText = typeof text === "string" && text.trim() ? text : getModeLoadingText();
    if (rewriteShimmerText) {
      rewriteShimmerText.textContent = labelText;
    }
  };

  const renderStatus = (text) => {
    clearSuggestionRevealTimers();
    suggestionBody.className = "suggestion-body centered";
    suggestionBody.innerHTML = `<p>${text}</p>`;
  };

  const renderError = (text) => {
    clearSuggestionRevealTimers();
    suggestionBody.className = "suggestion-body centered error";
    suggestionBody.innerHTML = `<p>${text || "Something went wrong. Try again in a bit."}</p>`;
  };

  const renderSuggestions = (items) => {
    if (!items.length) {
      renderStatus("No response.");
      return;
    }

    const { list, cards } = renderSkeletonPlaceholders(items.length);
    if (!cards.length || !list) {
      skeletonActive = false;
      skeletonVisibleSince = 0;
      const fallbackCards = items
        .map(
          (item) => `
        <article class="suggestion-card">
          <p>${item.text}</p>
          <div class="suggestion-meta">
            <span class="suggestion-char">${formatCharCount(item.charCount ?? item.text.length)}</span>
          </div>
        </article>`
        ) 
        .join("");
      suggestionBody.className = "suggestion-body";
      suggestionBody.innerHTML = `<div class="suggestions-list">${fallbackCards}</div>`;
      return;
    }
    scheduleSuggestionReveal(cards, items, list);
  };

  const saveSuggestionsSnapshot = (payload) => {
    try {
      if (!window.localStorage) return;
      const serialized = JSON.stringify(payload);
      window.localStorage.setItem(SUGGESTION_STORAGE_KEY, serialized);
    } catch (err) {
      console.warn("Unable to save suggestions to storage:", err);
    }
  };

  const loadSuggestionsSnapshot = () => {
    try {
      if (!window.localStorage) return null;
      const raw = window.localStorage.getItem(SUGGESTION_STORAGE_KEY);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!parsed || !Array.isArray(parsed.suggestions) || !parsed.suggestions.length) {
        return null;
      }
      return parsed;
    } catch (err) {
      console.warn("Unable to read suggestions from storage:", err);
      return null;
    }
  };

  const restoreSuggestionsFromStorage = () => {
    const snapshot = loadSuggestionsSnapshot();
    if (!snapshot) return false;
    const { suggestions } = snapshot;
    if (!Array.isArray(suggestions) || !suggestions.length) {
      return false;
    }
    showSuggestionsScreen();
    renderSuggestions(suggestions);
    return true;
  };

  const stripFormatting = (line) =>
    line
      .replace(/[*_`]/g, "")
      .replace(/^\d+[\.)-]*\s*/, "")
      .replace(/^[-•*]+\s*/, "")
      .replace(/\s+/g, " ")
      .trim();
  const stripTrailingCharCount = (text) => {
    if (!text) return text;
    return text.replace(/\s*\(\s*~?\d+\s*(?:char(?:s)?|character(?:s)?)\s*\)\s*$/i, "").trim();
  };

  const looksLikeMeta = (line) => {
    const lower = line.toLowerCase();
    const normalized = lower.replace(/[’]/g, "'");
    if (!lower) return true;
    if (lower.length <= 2) return true;
    const metaPrefixes = [
      "here are",
      "here's",
      "these are",
      "please note",
      "okay, i'm",
      "alright, i'm",
      "i'm ready",
      "let me",
      "i will",
      "i can",
      "remember:",
      "for reference",
      "guideline:",
      "dialog:",
      "instruction:",
    ];
    if (metaPrefixes.some((p) => lower.startsWith(p))) return true;
    if (/^option\s*\d+/i.test(lower)) return true;
    if (lower.startsWith("option ") || lower.startsWith("option:")) return true;
    if (lower.includes("option ") && lower.endsWith(":")) return true;
    if (lower.includes("dialog") || lower.includes("instruction")) return true;
    if (lower.endsWith(":") && (lower.includes("requirement") || lower.includes("suggestion"))) return true;
    if (lower.includes("i've provided") || lower.includes("i have provided")) return true;
    if (lower.includes("below are") || lower.includes("as requested")) return true;
    const conversationalPatterns = [
      /we understand\b/,
      /we know\b/,
      /we're here\b/,
      /it's great you're\b/,
      /it is great you're\b/,
      /let's see\b/,
      /let's find\b/,
      /let's check\b/,
      /let's explore\b/,
      /let's walk\b/,
      /let's take\b/,
      /let's talk\b/,
      /let's get you\b/,
    ];
    if (conversationalPatterns.some((pattern) => pattern.test(normalized))) return true;
    return false;
  };

  const expandNumberedItems = (text) => {
    if (!/\d+[\.)-]/.test(text)) return null;
    const segments = text
      .split(/\d+[\.)-]\s*/g)
      .map((segment) => segment.trim())
      .filter(Boolean);
    return segments.length >= 2 ? segments : null;
  };

  const classifyLength = (count) => {
    if (count <= 45) return "Short";
    if (count <= 80) return "Medium";
    return "Long";
  };
  const buildSuggestions = (raw) => {
    if (!raw) return [];

    const expandedRaw = raw.replace(/(\d+[\.)-])/g, "\n$1");
    let blocks = expandedRaw.split(/\n{2,}/);
    if (blocks.length === 1) {
      blocks = expandedRaw.split(/\n+/);
    }

    const normalized = blocks
      .map((block) => stripFormatting(block))
      .filter(Boolean)
      .filter((block) => !looksLikeMeta(block));

    const flattened = normalized.flatMap((text) => {
      const expanded = expandNumberedItems(text);
      return expanded && expanded.length ? expanded : [text];
    });

    const unique = [];
    const seen = new Set();
    flattened.forEach((text) => {
      const clean = stripTrailingCharCount(stripFormatting(text));
      if (!clean) return;
      const key = clean.toLowerCase();
      if (!seen.has(key)) {
        seen.add(key);
        unique.push(clean);
      }
    });

    const enriched = unique.map((text) => {
      const charCount = text.length;
      return {
        text,
        charCount,
        lengthLabel: classifyLength(charCount),
      };
    });

    const bucketOrder = ["Short", "Medium", "Long"];
    const bucketTargets = {
      Short: 3,
      Medium: 3,
      Long: 3,
    };
    const buckets = {
      Short: [],
      Medium: [],
      Long: [],
    };
    enriched.forEach((item) => {
      if (buckets[item.lengthLabel]) {
        buckets[item.lengthLabel].push(item);
      } else {
        buckets.Long.push(item);
      }
    });

    const selected = [];
    const usedKeys = new Set();

    bucketOrder.forEach((bucket) => {
      const bucketItems = buckets[bucket] || [];
      const target = bucketTargets[bucket] || 0;
      let count = 0;
      for (const item of bucketItems) {
        const key = item.text.toLowerCase();
        if (usedKeys.has(key)) continue;
        selected.push(item);
        usedKeys.add(key);
        count += 1;
        if (count >= target) break;
      }
    });

    if (selected.length < MIN_SUGGESTIONS) {
      enriched.forEach((item) => {
        if (selected.length >= MIN_SUGGESTIONS) return;
        const key = item.text.toLowerCase();
        if (!usedKeys.has(key)) {
          selected.push(item);
          usedKeys.add(key);
        }
      });
    }

    return selected.slice(0, MIN_SUGGESTIONS).map((item, idx) => ({
      ...item,
      score: Math.max(80, 95 - idx * 2),
      tones: toneFallbacks[idx % toneFallbacks.length],
    }));
  };

  const applySelectionText = (text) => {
    if (!text) return;
    inputField.value = text;
    inputField.dispatchEvent(new Event("input"));
  };

  updateContextHints();

  usageContextInput?.addEventListener("input", () => {
    usageContextValue = usageContextInput.value.trim();
    resizeContextInput();
    updateContextHints();
  });

  btnRewrite.onclick = async () => {
    commitAllManualKeywords();
    const text = inputField.value.trim();
    if (!text) {
      alert("Please enter some text.");
      return;
    }
    const mode = generationMode;
    const guidelinePayload = buildGuidelinePayload();
    setRewriteLoadingState(true);
    renderLoading();

    const key = geminiKeyInput ? geminiKeyInput.value.trim() : "";
    if (!key) {
      postToPlugin({ type: "load-key" });
      renderLoading("Loading saved key…");
      window.__pendingText = text;
      window.__pendingGuideline = guidelinePayload;
      window.__pendingMode = mode;
      return;
    }

    delete window.__pendingGuideline;
    delete window.__pendingMode;
    postToPlugin({
      type: "rewrite",
      key,
      text,
      guideline: guidelinePayload,
      mode,
      elementFocus: selectedElementId,
    });
  };

  inputField.addEventListener("input", () => {
    const hasText = Boolean(inputField.value.trim());
    updateRewriteButtonState();
    updateInputCharCount();
    resizeRewriteInput();
    if (!hasText && !window.__pendingText) {
      renderEmptyState();
    }
  });

  // settings save/load
  saveKeyBtn.onclick = () => {
    const key = geminiKeyInput.value.trim();
    postToPlugin({ type: "save-key", key });
    saveStatus.textContent = "Saving…";
  };
  loadKeyBtn.onclick = () => {
    postToPlugin({ type: "load-key" });
    saveStatus.textContent = "Loading…";
  };

  // messages from main
  onmessage = (event) => {
    const msg = event.data.pluginMessage;

    if (msg?.type === "guideline-default") {
      if (msg.error) {
        guidelineReference = null;
        setGuidelineIndicator("error", "Couldn't load style guide. Using fallback.");
        guidelineMeta.rewriteOverview = "";
        guidelineMeta.rewriteRequirements = [];
        applyLengthGuide(null);
        applySentenceLibrary(null);
        updateContextHints();
      } else if (msg.guideline) {
        guidelineReference = msg.guideline;
        setGuidelineIndicator("loaded", "Using structured style guide.");
        applyGuidelineMeta(msg.guideline);
      } else {
        guidelineReference = null;
        setGuidelineIndicator("fallback", "Using fallback style guide.");
        guidelineMeta.rewriteOverview = "";
        guidelineMeta.rewriteRequirements = [];
        applyLengthGuide(null);
        applySentenceLibrary(null);
        updateContextHints();
      }
      return;
    }

    if (msg?.type === "key-saved") {
      saveStatus.textContent = msg.error ? ("Save failed: " + msg.error) : "Key saved.";
      if (!msg.error && typeof msg.key === "string") {
        geminiKeyInput.value = msg.key;
      }
      return;
    }
    if (msg?.type === "key-loaded") {
      if (msg.error) {
        saveStatus.textContent = "Load failed: " + msg.error;
        setRewriteLoadingState(false);
        if (window.__pendingText) {
          showSuggestionsScreen();
          renderStatus("Couldn't load your API key. Add it in Settings to try again.");
          delete window.__pendingText;
          delete window.__pendingGuideline;
          activate("settings");
        }
        return;
      }

      const loadedKeyRaw = typeof msg.key === "string" ? msg.key : "";
      const loadedKey = loadedKeyRaw.trim();

      geminiKeyInput.value = loadedKeyRaw;
      saveStatus.textContent = loadedKey ? "Key loaded." : "No key saved yet.";

      if (window.__pendingText) {
        if (loadedKey) {
          const text = window.__pendingText;
          const guide = window.__pendingGuideline || buildGuidelinePayload();
          const pendingMode = window.__pendingMode || generationMode;
          delete window.__pendingText;
          delete window.__pendingGuideline;
          delete window.__pendingMode;
          postToPlugin({
            type: "rewrite",
            key: loadedKey,
            text,
            guideline: guide,
            mode: pendingMode,
            elementFocus: selectedElementId,
          });
          setRewriteLoadingState(true);
          renderLoading();
        } else {
          setRewriteLoadingState(false);
          showSuggestionsScreen();
          renderStatus("Add your Gemini API key in Settings to generate copy suggestions.");
          delete window.__pendingText;
          delete window.__pendingGuideline;
          delete window.__pendingMode;
          activate("settings");
        }
      }
      return;
    }
    if (msg?.type === "error") {
      const errText =
        typeof msg.error === "string"
          ? msg.error
          : msg && msg.error && msg.error.message
          ? String(msg.error.message)
          : "Unknown error.";
      console.error("Gemini rewrite error:", msg.error);
      setRewriteLoadingState(false);
      activate("rewrite");
      showSuggestionsScreen();
      renderError("Generation failed: " + errText);
      return;
    }
    if (msg?.type === "selection-text") {
      if (typeof msg.text === "string" && msg.text.length) {
        applySelectionText(msg.text);
      }
      return;
    }
    if (msg?.type === "rewrite-done") {
      const output = typeof msg.output === "string" ? msg.output.trim() : "";
      setRewriteLoadingState(false);
      showSuggestionsScreen();
      if (msg.error) {
        renderError(output);
      } else {
        const suggestions = buildSuggestions(output);
        if (suggestions.length) {
          renderSuggestions(suggestions);
          saveSuggestionsSnapshot({
            suggestions,
            sourceText: inputField?.value?.trim() || "",
            usageContext: usageContextValue,
            storedAt: Date.now(),
          });
        } else {
          renderError(output || "No response.");
        }
      }
      activate("rewrite");
      return;
    }
  };

  // auto-load key when opening settings
  tabs.settings.tab.addEventListener("click", ()=> {
    postToPlugin({ type: "load-key" });
    saveStatus.textContent = "Loading…";
  });

  updateInputCharCount();
  resizeRewriteInput();
  resizeContextInput();
  renderEmptyState();
  postToPlugin({ type: "request-guideline" });
</script>
