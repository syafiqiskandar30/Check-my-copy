<!doctype html>
<meta charset="utf-8" />
<style>
  :root {
    --bg: #fff;
    --muted: #f5f5f7;
    --line: #e6e6e6;
    --primary: #7f56d9;
    --text: #111827;
    --subtle: #6b7280;
    --chip-bg: #fff;
    --chip-border: #d1d5db;
  }
  *,
  *::before,
  *::after {
    box-sizing: border-box;
  }
  html,
  body {
    font: 14px/1.4 "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
    margin: 0;
    width: 100%;
    max-width: 100%;
    background: var(--bg);
    color: var(--text);
    overflow-x: hidden;
  }
  .tabs {
    display: flex;
    gap: 6px;
    padding: 4px;
    margin: 12px;
    border-radius: 8px;
    background: rgba(0, 0, 0, 0.05);
  }
  .tab {
    flex: 1;
    text-align: center;
    padding: 9px 16px;
    border-radius: 8px;
    cursor: pointer;
    user-select: none;
    font-family: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
    font-weight: 500;
    font-size: 15px;
    line-height: 18px;
    color: #788494;
    transition: color 0.15s ease, background 0.15s ease, box-shadow 0.15s ease;
  }
  .tab.active {
    background: #fff;
    color: #2d333a;
  }
  .panel {
    padding: 12px;
    display: none;
  }
  .panel.active {
    display: block;
  }
  .rewrite-screen {
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.25s ease;
    pointer-events: none;
  }
  .rewrite-screen.active {
    opacity: 1;
    visibility: visible;
    pointer-events: auto;
  }
  .rewrite-screen[hidden] {
    display: none !important;
  }
  .rewrite-screen.loading-screen {
    display: flex;
  }
  .loading-screen {
    min-height: 320px;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 16px;
    text-align: center;
    padding: 32px 16px;
  }
  .loading-screen p {
    margin: 0;
    font-size: 16px;
    line-height: 22px;
    color: #111827;
    font-weight: 500;
    white-space: pre-line;
  }
  .loading-illustration {
    width: 112px;
    height: 112px;
    border-radius: 50%;
    background: #e3f2ff;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .loading-illustration svg {
    width: 90px;
    height: 90px;
    display: block;
  }
  .back-button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    border: none;
    background: transparent;
    cursor: pointer;
    padding: 4px;
    border-radius: 999px;
  }
  .back-button svg {
    width: 24px;
    height: 24px;
    display: block;
  }
  .back-button:focus-visible {
    outline: 2px solid #7f56d9;
    outline-offset: 2px;
  }
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    border: 0;
  }
  .suggestions-screen {
    padding: 16px 0 16px;
  }
  .suggestions-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 16px;
  }
  .suggestions-header h2 {
    margin: 0;
    color: #000;
    font-size: 18px;
    font-style: normal;
    font-weight: 600;
    line-height: 27px;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .field-header {
    display: flex;
    align-items: flex-end;
    justify-content: space-between;
    margin-bottom: 6px;
  }
  .field-label {
    color: #525b65;
    font-size: 14px;
    line-height: 20px;
    font-weight: 500;
  }
  .tone-section {
    margin-top: 32px;
  }
  .tone-title {
    color: #525b65;
    font-size: 14px;
    line-height: 20px;
    font-weight: 500;
  }
  .tone-options,
  .element-options {
    margin-top: 12px;
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
  }
  .tone-chip,
  .element-chip {
    border: 1px dashed #f5f5f5;
    border-radius: 12px;
    background: #fff;
    padding: 10px 14px;
    min-width: 112px;
    display: inline-flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
    cursor: pointer;
    font-family: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
    font-size: 14px;
    line-height: 17px;
    font-weight: 500;
    color: #788494;
    text-align: center;
    transition: border-color 0.15s ease, background 0.15s ease, color 0.15s ease, box-shadow 0.15s ease;
  }
  .tone-chip-icon,
  .element-chip-icon {
    width: 20px;
    height: 20px;
    display: inline-block;
    flex-shrink: 0;
  }
  .tone-chip-label,
  .element-chip-label {
    color: inherit;
    font-family: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
    font-size: 14px;
    font-style: normal;
    font-weight: 500;
    line-height: 17px;
    text-align: center;
    flex: 1 1 auto;
  }
  .tone-chip.is-selected,
  .element-chip.is-selected {
    border-style: solid;
    border-color: transparent;
    border-radius: 12px;
    background: rgba(0, 176, 255, 0.1);
    color: #00b0ff;
  }
  .tone-chip:focus-visible,
  .element-chip:focus-visible {
    outline: 2px solid #00b0ff;
    outline-offset: 2px;
  }
  .tone-chip:disabled,
  .element-chip:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    border-color: #f0f2f7;
    background: #fff;
    color: #c0c7d4;
  }
  .tone-chip:disabled .tone-chip-icon,
  .element-chip:disabled .element-chip-icon {
    opacity: 0.5;
  }
  .element-chip {
    min-width: auto;
    flex: 0 0 auto;
    justify-content: flex-start;
    text-align: left;
    gap: 6px;
  }
  .element-chip .element-chip-label {
    text-align: left;
  }
  .element-section {
    margin-top: 32px;
  }
  .length-section {
    margin-top: 32px;
  }
  .length-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    color: #525b65;
    font-size: 14px;
    line-height: 20px;
    font-weight: 500;
  }
  .length-header .length-value {
    color: var(--Typography-Light-Grey, #788494);
    font-family: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
    font-size: 12px;
    font-style: normal;
    font-weight: 400;
    line-height: 18px;
  }
  .length-slider {
    position: relative;
    margin-top: 12px;
    width: 100%;
    height: 36x;
    display: flex;
    align-items: center;
  }
  .length-slider-track {
    position: absolute;
    inset: 0;
    border-radius: 999px;
    background: #f5f5f5;
    overflow: hidden;
  }
  .length-slider-fill {
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    width: 0;
    border-radius: 999px;
    background: #00b0ff;
  }
  .length-slider input[type="range"] {
    position: relative;
    z-index: 2;
    width: 100%;
    height: 100%;
    margin: 0;
    -webkit-appearance: none;
    appearance: none;
    background: transparent;
    cursor: pointer;
  }
  .length-slider input[type="range"]::-webkit-slider-runnable-track {
    height: 100%;
    background: transparent;
  }
  .length-slider input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background: #fff;
    border: 4px solid #00b0ff;
    box-shadow: none;
  }
  .length-slider input[type="range"]::-moz-range-thumb {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background: #fff;
    border: 4px solid #00b0ff;
    box-shadow: none;
  }
  .element-title {
    color: #525b65;
    font-size: 14px;
    line-height: 20px;
    font-weight: 500;
  }
  textarea,
  input[type="text"] {
    width: 100%;
    padding: 12px;
    border: 1px solid #f5f5f5;
    border-radius: 4px;
    font-family: inherit;
    font-size: 14px;
    box-sizing: border-box;
    transition: border-color 0.15s ease;
  }
  textarea {
    resize: none;
    min-height: 52px;
    overflow-y: hidden;
    margin: 0;
  }
  textarea::placeholder,
  input[type="text"]::placeholder {
    color: #788494;
    line-height: 20px;
  }
  textarea:focus,
  input[type="text"]:focus {
    border-color: #00b0ff;
    outline: none;
  }
  .guideline-status {
    margin: 8px 0 0;
    font-size: 12px;
    color: var(--subtle);
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .guideline-status .status-dot {
    width: 8px;
    height: 8px;
    border-radius: 999px;
    background: #d1d5db;
  }
  .guideline-status.loaded .status-dot {
    background: #34d399;
  }
  .guideline-status.fallback .status-dot {
    background: #fbbf24;
  }
  .guideline-status.error .status-dot {
    background: #f87171;
  }
  .chips {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    margin-top: 10px;
  }
  .chip-dropdown {
    position: relative;
  }
  .chip {
    border: 1px solid var(--chip-border);
    background: var(--chip-bg);
    border-radius: 999px;
    padding: 4px 12px;
    font-size: 13px;
    cursor: pointer;
  }
  .chip.is-selected {
    background: #ede9fe;
    border-color: #c4b5fd;
    color: #5b21b6;
    font-weight: 600;
  }
  .chip:focus-visible {
    outline: 2px solid var(--primary);
  }
  .rewrite-btn {
    width: 100%;
    margin-top: 16px;
    padding: 12px;
    border: 0;
    border-radius: 12px;
    background: #00b0ff;
    color: #fff;
    font-weight: 600;
    font-size: 14px;
    line-height: 17px;
    letter-spacing: 1px;
    text-transform: uppercase;
    cursor: pointer;
    text-align: center;
    position: relative;
    overflow: hidden;
  }
  .rewrite-btn:disabled:not(.is-loading) {
    cursor: default;
    opacity: 0.65;
  }
  .rewrite-label,
  .rewrite-shimmer {
    display: block;
    transition: opacity 0.2s ease;
  }
  .rewrite-shimmer {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: linear-gradient(110deg, rgba(255,255,255,0.4), #fff, rgba(255,255,255,0.4));
    background-size: 200% auto;
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    animation: shimmerText 1.4s linear infinite;
    font-weight: 700;
    letter-spacing: 0.08em;
    opacity: 0;
    pointer-events: none;
  }
  .rewrite-btn.is-loading .rewrite-label {
    opacity: 0;
  }
  .rewrite-btn.is-loading .rewrite-shimmer {
    opacity: 1;
  }
  @keyframes shimmerText {
    0% {
      background-position: -100% 0;
    }
    100% {
      background-position: 200% 0;
    }
  }
  .suggestions {
    margin-top: 0;
    border: 0;
    padding-top: 0;
  }
  .suggestion-body {
    min-height: 0;
    padding: 0;
    color: var(--subtle);
    display: flex;
    flex-direction: column;
    gap: 10px;
  }
  .suggestion-body.centered {
    padding: 16px;
    min-height: 140px;
    justify-content: center;
    align-items: center;
    text-align: center;
    border-radius: 12px;
    background: var(--muted);
  }
  .suggestion-body.error {
    background: #fef2f2;
    color: #991b1b;
    border: 1px solid #fecaca;
  }
  .suggestion-body.centered .empty-arrow {
    font-size: 30px;
    color: #d1d5db;
  }
  .suggestions-list {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }
  .suggestion-card {
    border-radius: 12px;
    border: 1px solid #f1f1f3;
    background: #f8f8fa;
    padding: 12px 14px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    color: #1f2933;
    transition: opacity 0.3s ease, transform 0.3s ease;
    cursor: default;
  }
  .suggestion-card p {
    margin: 0;
    font-size: 14px;
  }
  .suggestion-meta {
    display: flex;
    align-items: flex-start;
    gap: 4px;
    align-self: stretch;
    color: #788494;
    font-family: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
    font-size: 14px;
    font-style: normal;
    font-weight: 400;
    line-height: 20px;
  }
  .suggestion-dot {
    color: inherit;
  }
  .suggestion-card.is-interactive {
    cursor: pointer;
  }
  .suggestion-card.is-interactive:focus-visible {
    outline: 2px solid #00b0ff;
    outline-offset: 2px;
  }
  .suggestion-card.is-interactive:active {
    transform: translateY(1px);
  }
  .suggestions-list.is-loading .suggestion-card {
    opacity: 1;
  }
  .suggestion-card.skeleton {
    position: relative;
    overflow: hidden;
  }
  .suggestion-card.revealing {
    opacity: 0;
    transform: translateY(8px);
  }
  .suggestion-card.revealed {
    opacity: 1;
    transform: translateY(0);
  }
  .skeleton-block {
    background: #e0e0e0;
    position: relative;
    overflow: hidden;
    display: block;
  }
  .skeleton-block::before {
    content: "";
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(
      90deg,
      transparent 0%,
      rgba(255, 255, 255, 0.6) 50%,
      transparent 100%
    );
    animation: shimmer 1.5s infinite;
  }
  @keyframes shimmer {
    0% {
      left: -100%;
    }
    100% {
      left: 100%;
    }
  }
  .skeleton-line,
  .skeleton-pill {
    display: block;
    width: 100%;
    border-radius: 999px;
  }
  .skeleton-line {
    height: 12px;
    margin-bottom: 8px;
  }
  .skeleton-line.long {
    width: 90%;
  }
  .skeleton-line.short {
    width: 55%;
  }
  .skeleton-pill {
    height: 10px;
    width: 72px;
  }
  .skeleton-pill.short {
    width: 42px;
  }
  .skeleton-meta {
    display: flex;
    gap: 8px;
    align-items: center;
    margin-top: 6px;
  }
  @media (prefers-reduced-motion: reduce) {
    .skeleton-block::before {
      animation: none;
    }
  }
  .score-pill {
    background: #d1fae5;
    color: #0f5132;
    border-radius: 6px;
    padding: 2px 8px;
    font-weight: 600;
    font-size: 12px;
  }
  .row {
    display: flex;
    gap: 8px;
    align-items: center;
  }
  .status-text {
    margin-top: 8px;
    font-size: 12px;
    color: var(--subtle);
  }
  .muted-text {
    font-size: 12px;
    color: var(--subtle);
  }
  .context-field {
    margin-top: 24px;
  }
  .context-field label {
    display: block;
    margin-bottom: 8px;
    font-size: 14px;
    line-height: 20px;
    font-weight: 500;
    color: #525b65;
  }
  .context-area {
    width: 100%;
    border: 1px solid #f5f5f5;
    border-radius: 4px;
    background: #fff;
    padding: 12px;
    font-size: 14px;
    line-height: 20px;
    font-family: inherit;
    resize: none;
  }
  .context-area::placeholder {
    color: #94a3b8;
  }
  .char-counter {
    font-size: 12px;
    line-height: 18px;
    color: #788494;
  }
</style>

<div class="tabs">
  <div id="tab-rewrite" class="tab active">Rewrite</div>
  <div id="tab-settings" class="tab">Settings</div>
</div>

<div id="panel-rewrite" class="panel active">
  <div class="rewrite-screen-container">
    <div id="rewriteHome" class="rewrite-screen active">
      <div class="field-header">
        <label class="field-label" for="inputText">Enter copy</label>
        <div id="inputCharCount" class="char-counter">0 characters</div>
      </div>
      <textarea
        id="inputText"
        class="auto-textarea"
        rows="2"
        placeholder="Type your copy or select a text layer in figma"
      ></textarea>
      <section class="tone-section">
        <div class="tone-title">Select tone</div>
        <div id="toneOptionList" class="tone-options"></div>
      </section>
      <section class="length-section">
        <div class="length-header">
          <span>Text length</span>
          <span id="lengthValue" class="length-value">0 characters</span>
        </div>
        <div class="length-slider">
          <div class="length-slider-track">
            <div id="lengthFill" class="length-slider-fill" style="width:0%;"></div>
          </div>
          <input type="range" id="lengthSlider" min="12" max="160" value="40" step="1" />
        </div>
      </section>
      <section class="element-section">
        <div class="element-title">Select usage</div>
        <div id="elementOptionList" class="element-options"></div>
      </section>
      <div class="context-field">
        <label for="usageContextInput">Context and custom instructions</label>
        <textarea
          id="usageContextInput"
          class="context-area auto-textarea"
          rows="2"
          placeholder="Use on fuelling flow.&#10;Do not use word &ldquo;free&rdquo;."
        ></textarea>
      </div>

      <button id="rewrite" class="rewrite-btn" disabled aria-live="polite">
        <span class="rewrite-label">Rewrite</span>
        <span id="rewriteShimmerText" class="rewrite-shimmer" aria-hidden="true">Crafting copy…</span>
      </button>
    </div>

    <div id="suggestionsScreen" class="rewrite-screen suggestions-screen" hidden>
      <div class="suggestions-header">
        <button type="button" id="backToForm" class="back-button" aria-label="Back to rewrite form">
          <span class="sr-only">Back</span>
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
            <path d="M15.5303 4.46967C15.2641 4.2034 14.8474 4.1792 14.5538 4.39705L14.4697 4.46967L7.46967 11.4697C7.2034 11.7359 7.1792 12.1526 7.39705 12.4462L7.46967 12.5303L14.4697 19.5303C14.7626 19.8232 15.2374 19.8232 15.5303 19.5303C15.7966 19.2641 15.8208 18.8474 15.6029 18.5538L15.5303 18.4697L9.061 12L15.5303 5.53033C15.7966 5.26406 15.8208 4.8474 15.6029 4.55379L15.5303 4.46967Z" fill="#2d333a"/>
          </svg>
        </button>
        <h2>Suggestions</h2>
      </div>
      <section class="suggestions">
        <div id="suggestionBody" class="suggestion-body centered"></div>
      </section>
    </div>
  </div>
</div>

<div id="panel-settings" class="panel">
  <div id="guidelineStatus" class="guideline-status fallback">
    <span class="status-dot"></span>
    <span class="guideline-text">Loading style guide…</span>
  </div>
  <label>API key (Gemini)</label>
  <input id="apikey" type="text" placeholder="AIza..." />
  <div class="row">
    <button id="saveKey">Save key</button>
    <button id="loadKey">Load key</button>
  </div>
  <div id="saveStatus" style="margin-top:8px;color:#555;"></div>
</div>

<script>
  // tab switching
  const tabs = {
    rewrite: { tab: document.getElementById("tab-rewrite"), panel: document.getElementById("panel-rewrite") },
    settings:{ tab: document.getElementById("tab-settings"), panel: document.getElementById("panel-settings") },
  };
  function activate(name){
    Object.values(tabs).forEach(({tab,panel})=>{
      tab.classList.remove("active"); panel.classList.remove("active");
    });
    tabs[name].tab.classList.add("active"); tabs[name].panel.classList.add("active");
  }
  tabs.rewrite.tab.onclick=()=>activate("rewrite");
  tabs.settings.tab.onclick=()=>{
    activate("settings");
  };

  // rewrite flow
  const btnRewrite = document.getElementById("rewrite");
  const suggestionBody = document.getElementById("suggestionBody");
  const rewriteHomeScreen = document.getElementById("rewriteHome");
  const suggestionsScreen = document.getElementById("suggestionsScreen");
  const backToFormBtn = document.getElementById("backToForm");
  const rewriteShimmerText = document.getElementById("rewriteShimmerText");
  const screenViews = {
    home: rewriteHomeScreen,
    suggestions: suggestionsScreen,
  };
  const SCREEN_FADE_MS = 250;
  const viewHideTimers = new WeakMap();
  const cancelPendingHide = (view) => {
    const timerId = viewHideTimers.get(view);
    if (timerId) {
      clearTimeout(timerId);
      viewHideTimers.delete(view);
    }
  };
  const scheduleHide = (view) => {
    if (!view) return;
    cancelPendingHide(view);
    const timerId = setTimeout(() => {
      if (!view.classList.contains("active")) {
        view.hidden = true;
      }
      viewHideTimers.delete(view);
    }, SCREEN_FADE_MS + 75);
    viewHideTimers.set(view, timerId);
  };
  const scrollToTop = () => {
    if (typeof window === "undefined") return;
    requestAnimationFrame(() => {
      const scroller = document.scrollingElement || document.documentElement || document.body;
      if (scroller) {
        scroller.scrollTop = 0;
      }
      if (typeof window.scrollTo === "function") {
        window.scrollTo(0, 0);
      }
    });
  };
  const showScreen = (name) => {
    const target = screenViews[name];
    if (!target) return;
    if (target.classList.contains("active")) return;
    Object.entries(screenViews).forEach(([key, view]) => {
      if (!view) return;
      const isActive = key === name;
      if (isActive) {
        cancelPendingHide(view);
        view.hidden = false;
        requestAnimationFrame(() => view.classList.add("active"));
      } else if (view.classList.contains("active")) {
        view.classList.remove("active");
        scheduleHide(view);
      } else {
        view.classList.remove("active");
        view.hidden = true;
      }
    });
    if (name === "suggestions" || name === "home") {
      scrollToTop();
    }
  };
  const showHomeScreen = () => showScreen("home");
  const showSuggestionsScreen = () => showScreen("suggestions");
  backToFormBtn?.addEventListener("click", () => {
    showHomeScreen();
  });
  showHomeScreen();
  const inputField = document.getElementById("inputText");
  const inputCharCounter = document.getElementById("inputCharCount");
  const MIN_SUGGESTIONS = 5;
  const toneFallbacks = [
    ["Engaging", "Friendly"],
    ["Warm", "Appreciative"],
    ["Enthusiastic", "Encouraging"],
    ["Upbeat", "Supportive"],
    ["Confident", "Empowering"],
  ];
  const MIN_INPUT_HEIGHT = 52;
  const DEFAULT_LOADING_TEXT = "Crafting copy…";
  let rewriteInProgress = false;
  const updateRewriteButtonState = () => {
    if (!btnRewrite) return;
    if (rewriteInProgress) {
      btnRewrite.disabled = true;
      return;
    }
    const hasText = Boolean(inputField?.value.trim());
    btnRewrite.disabled = !hasText;
  };
  const setRewriteLoadingState = (isLoading, text = DEFAULT_LOADING_TEXT) => {
    rewriteInProgress = Boolean(isLoading);
    if (btnRewrite) {
      btnRewrite.classList.toggle("is-loading", rewriteInProgress);
      btnRewrite.setAttribute("aria-busy", rewriteInProgress ? "true" : "false");
    }
    if (rewriteShimmerText && typeof text === "string" && text.trim()) {
      rewriteShimmerText.textContent = text;
    } else if (rewriteShimmerText && !rewriteShimmerText.textContent.trim()) {
      rewriteShimmerText.textContent = DEFAULT_LOADING_TEXT;
    }
    updateRewriteButtonState();
  };
  const autoResizeTextarea = (element, minHeight = MIN_INPUT_HEIGHT) => {
    if (!element) return;
    element.style.height = "auto";
    const nextHeight = Math.max(element.scrollHeight, minHeight);
    element.style.height = `${nextHeight}px`;
  };
  const resizeRewriteInput = () => {
    autoResizeTextarea(inputField, MIN_INPUT_HEIGHT);
  };

  const geminiKeyInput = document.getElementById("apikey");
  const saveKeyBtn = document.getElementById("saveKey");
  const loadKeyBtn = document.getElementById("loadKey");
  const saveStatus = document.getElementById("saveStatus");
  const guidelineStatus = document.getElementById("guidelineStatus");
  const guidelineStatusText = guidelineStatus?.querySelector(".guideline-text");
  const usageContextInput = document.getElementById("usageContextInput");
  const MIN_CONTEXT_HEIGHT = 72;
  const CONTEXT_LINE_HEIGHT = 20;
  const CONTEXT_VERTICAL_PADDING = 24;
  const DEFAULT_CONTEXT_PLACEHOLDER = "";
  const DEFAULT_PLACEHOLDER_LINES = 1;
  let contextPlaceholderSizer = null;
  const updateContextPlaceholder = (text, lineCount = DEFAULT_PLACEHOLDER_LINES) => {
    if (!usageContextInput) return;
    usageContextInput.placeholder = text;
    const totalLines = Math.max(lineCount, DEFAULT_PLACEHOLDER_LINES);
    let minHeight = Math.max(
      MIN_CONTEXT_HEIGHT,
      CONTEXT_VERTICAL_PADDING + totalLines * CONTEXT_LINE_HEIGHT
    );
    if (!contextPlaceholderSizer) {
      contextPlaceholderSizer = document.createElement("div");
      contextPlaceholderSizer.setAttribute("aria-hidden", "true");
      contextPlaceholderSizer.style.position = "absolute";
      contextPlaceholderSizer.style.visibility = "hidden";
      contextPlaceholderSizer.style.whiteSpace = "pre-wrap";
      contextPlaceholderSizer.style.wordBreak = "break-word";
      contextPlaceholderSizer.style.top = "-9999px";
      contextPlaceholderSizer.style.left = "-9999px";
      contextPlaceholderSizer.style.pointerEvents = "none";
      contextPlaceholderSizer.style.boxSizing = "border-box";
      document.body.appendChild(contextPlaceholderSizer);
    }
    const computed = getComputedStyle(usageContextInput);
    contextPlaceholderSizer.style.font = computed.font || "";
    contextPlaceholderSizer.style.lineHeight = computed.lineHeight || "";
    contextPlaceholderSizer.style.padding = computed.padding || "";
    contextPlaceholderSizer.style.width = `${usageContextInput.clientWidth}px`;
    contextPlaceholderSizer.textContent = text;
    const measuredHeight = contextPlaceholderSizer.scrollHeight;
    minHeight = Math.max(minHeight, measuredHeight);
    usageContextInput.style.minHeight = `${minHeight}px`;
    if (!usageContextInput.value.trim().length) {
      usageContextInput.style.height = `${minHeight}px`;
    }
  };
  if (usageContextInput) {
    updateContextPlaceholder(DEFAULT_CONTEXT_PLACEHOLDER, DEFAULT_PLACEHOLDER_LINES);
  }
  const resizeContextInput = () => {
    autoResizeTextarea(usageContextInput, MIN_CONTEXT_HEIGHT);
  };
  let usageContextValue = "";
  const formatCharCount = (count) => `${count} character${count === 1 ? "" : "s"}`;
  const updateInputCharCount = () => {
    if (!inputCharCounter) return;
    const value = inputField?.value || "";
    inputCharCounter.textContent = formatCharCount(value.length);
  };
  const SUGGESTION_INITIAL_DELAY = 320;
  const SUGGESTION_REVEAL_STEP = 180;
  const SKELETON_MIN_DISPLAY_MS = 1100;
  let suggestionRevealTimers = [];
  let skeletonVisibleSince = 0;
  let skeletonActive = false;
  const reducedMotionQuery =
    typeof window !== "undefined" && window.matchMedia
      ? window.matchMedia("(prefers-reduced-motion: reduce)")
      : null;
  const prefersReducedMotion = () => Boolean(reducedMotionQuery?.matches);
  const clearSuggestionRevealTimers = () => {
    suggestionRevealTimers.forEach((timerId) => clearTimeout(timerId));
    suggestionRevealTimers = [];
    skeletonVisibleSince = 0;
    skeletonActive = false;
  };
  const resetSuggestionCardInteractivity = (card) => {
    if (!card) return;
    card.classList.remove("is-interactive", "revealed");
    card.removeAttribute("role");
    card.removeAttribute("tabindex");
    card.removeAttribute("data-text");
  };
  const createSkeletonCardElement = () => {
    const card = document.createElement("article");
    card.className = "suggestion-card skeleton";
    resetSuggestionCardInteractivity(card);
    card.innerHTML = `
      <div class="skeleton-line skeleton-block long"></div>
      <div class="skeleton-line skeleton-block"></div>
      <div class="skeleton-line skeleton-block short"></div>
      <div class="skeleton-meta">
        <span class="skeleton-pill skeleton-block"></span>
        <span class="skeleton-pill skeleton-block short"></span>
        <span class="skeleton-pill skeleton-block"></span>
      </div>
    `;
    return card;
  };
  const renderSkeletonPlaceholders = (count = MIN_SUGGESTIONS) => {
    if (!suggestionBody) return { list: null, cards: [] };
    clearSuggestionRevealTimers();
    suggestionBody.className = "suggestion-body";
    suggestionBody.innerHTML = "";
    const list = document.createElement("div");
    list.className = "suggestions-list is-loading";
    suggestionBody.appendChild(list);
    const total = Math.max(1, Number(count) || 0);
    const cards = [];
    for (let i = 0; i < total; i += 1) {
      const card = createSkeletonCardElement();
      list.appendChild(card);
      cards.push(card);
    }
    skeletonVisibleSince =
      typeof performance !== "undefined" && performance.now ? performance.now() : Date.now();
    skeletonActive = true;
    return { list, cards };
  };
  const revealCardContent = (card, item) => {
    if (!card) return;
    card.classList.remove("skeleton");
    card.dataset.text = item.text;
    card.innerHTML = `
      <p>${item.text}</p>
      <div class="suggestion-meta">
        <span>${item.tones.join(", ")}</span>
        <span class="suggestion-dot" aria-hidden="true">·</span>
        <span class="suggestion-char">${formatCharCount(item.text.length)}</span>
      </div>
    `;
    card.setAttribute("role", "button");
    card.tabIndex = 0;
    card.classList.add("is-interactive");
    card.addEventListener("click", handleSuggestionCardClick);
    card.addEventListener("keydown", handleSuggestionCardKeydown);
    card.classList.add("revealing");
    requestAnimationFrame(() => {
      card.classList.remove("revealing");
      card.classList.add("revealed");
    });
  };
  const scheduleSuggestionReveal = (cards, items, list) => {
    if (!cards.length || !items.length) return;
    const baseDelay = prefersReducedMotion() ? 0 : SUGGESTION_INITIAL_DELAY;
    const stepDelay = prefersReducedMotion() ? 0 : SUGGESTION_REVEAL_STEP;
    cards.forEach((card, idx) => {
      const now = typeof performance !== "undefined" && performance.now ? performance.now() : Date.now();
      const elapsed = Math.max(0, now - skeletonVisibleSince);
      const minVisibleOffset =
        skeletonActive && !prefersReducedMotion()
          ? Math.max(SKELETON_MIN_DISPLAY_MS - elapsed, 0)
          : 0;
      const timer = setTimeout(() => {
        revealCardContent(card, items[idx]);
        if (idx === cards.length - 1 && list) {
          list.classList.remove("is-loading");
          skeletonActive = false;
          skeletonVisibleSince = 0;
        }
      }, baseDelay + idx * stepDelay + minVisibleOffset);
      suggestionRevealTimers.push(timer);
    });
  };

  const fallbackGuideline = Object.freeze({
    name: "Warm lower-case headings",
    instructions:
      "Write 2-6 word lower-case headings with a warm, appreciative, enthusiastic tone. Keep copy mobile friendly and avoid emojis unless explicitly requested.",
    examples: [
      "thanks for being here",
      "we love having you",
      "you're in great company",
    ],
  });

  const filterSelections = {};
  const MAX_TONE_SELECTIONS = 2;
  const elementOptionList = document.getElementById("elementOptionList");
  const lengthSlider = document.getElementById("lengthSlider");
  const lengthValueEl = document.getElementById("lengthValue");
  const lengthFill = document.getElementById("lengthFill");
  const lengthPresetMarkers = document.getElementById("lengthPresetMarkers");
  const lengthPresetLabels = document.getElementById("lengthPresetLabels");
  const getToneSelections = () => {
    const tones = filterSelections.tone;
    if (Array.isArray(tones)) return tones;
    if (typeof tones === "string" && tones.length) return [tones];
    return [];
  };
  const setToneSelections = (tones) => {
    if (!tones || !tones.length) {
      delete filterSelections.tone;
    } else {
      filterSelections.tone = tones;
    }
  };

  const TONE_RENAME_MAP = Object.freeze({
    "friendly and conversational": "Warm",
    "professional and authoritative": "Firm",
    "persuasive and compelling": "Bold",
    "empathetic and reassuring": "Caring",
    "playful and humourous": "Fun",
    "playful and humorous": "Fun",
    "inspirational and motivational": "Inspire",
    "informative and neutral": "Clear",
    "urgent and action-oriented": "Urgent",
    "luxurious and exclusive": "Exclusive",
    "analytical and technical": "Factual",
  });
  const SIMPLE_TONE_LABELS = Object.freeze([
    "Warm",
    "Firm",
    "Bold",
    "Caring",
    "Fun",
    "Inspire",
    "Clear",
    "Urgent",
    "Exclusive",
    "Factual",
  ]);
  const FALLBACK_TONE_DATA = SIMPLE_TONE_LABELS.map((label) => ({
    value: label,
    label,
  }));
  const USAGE_RENAME_PAIRS = [
    ["web (feature pages) copy", "Web features"],
    ["web (features pages) copy", "Web features"],
    ["web (promo pages) copy", "Web promotions"],
    ["meta title and description", "Transactional"],
    ["meta details", "Transactional"],
    ["email (transactional)", "Transactional"],
    ["push notification and app inbox (transactional)", "Transactional"],
    ["push notifications and app inbox (transactional)", "Transactional"],
    ["push notification and app inbox (promo and nurturing)", "Promotional"],
    ["push notifications and app inbox (promo and nurturing)", "Promotional"],
    ["frequently asked questions/help centre articles (product)", "FAQs"],
    ["frequently asked questions (promotions)", "FAQs"],
    ["branding (taglines, unique selling points/usp)", "USP"],
  ];
  const USAGE_RENAME_MAP = Object.freeze(
    USAGE_RENAME_PAIRS.reduce((acc, [source, target]) => {
      const key = typeof source === "string" ? source.trim().toLowerCase() : "";
      if (key && typeof target === "string" && target.trim().length) {
        acc[key] = target.trim();
      }
      return acc;
    }, {})
  );
  const RAW_FALLBACK_USAGE_OPTIONS = [
    {
      value: "Heading",
      label: "Heading",
      description: "Short hero or section title that primes the message.",
      focus: ["Grab attention", "Frame the benefit"],
    },
    {
      value: "Description",
      label: "Description",
      description: "One to two sentences that explain the value.",
      focus: ["Give context", "Highlight differentiator"],
    },
    {
      value: "CTA Button",
      label: "CTA button",
      description: "Action-driven label that finishes the sentence “I want to…”.",
      focus: ["Use verbs", "Set expectations"],
    },
    {
      value: "Body",
      label: "Body",
      description: "Longer supporting copy for cards, modals, or pages.",
      focus: ["Structure info", "Keep it scannable"],
    },
    {
      value: "Tooltip",
      label: "Tooltip",
      description: "Quick clarification tucked behind an icon.",
      focus: ["Stay concise", "Address confusion"],
    },
    {
      value: "Empty state",
      label: "Empty state",
      description: "Friendly message that guides users when nothing is there yet.",
      focus: ["Acknowledge state", "Offer next step"],
    },
    {
      value: "Toast",
      label: "Toast",
      description: "Short confirmation or error banner.",
      focus: ["Confirm outcome", "Offer undo if possible"],
    },
    {
      value: "Label",
      label: "Label",
      description: "Short name that makes inputs and toggles clear.",
      focus: ["Be specific", "Avoid jargon"],
    },
  ];
  const guidelineMeta = {
    rewriteOverview: "",
    rewriteRequirements: [],
  };
  const LENGTH_PRESETS = [
    { label: "Short", value: 32 },
    { label: "Medium", value: 64 },
    { label: "Long", value: 106 },
  ];

  const escapeHtml = (text = "") =>
    String(text)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;");

  const simplifyToneLabel = (tone) => {
    const raw = typeof tone === "string" ? tone.trim() : "";
    if (!raw) return "";
    const mapped = TONE_RENAME_MAP[raw.toLowerCase()];
    return mapped || raw;
  };
  const simplifyUsageLabel = (label) => {
    const raw = typeof label === "string" ? label.trim() : "";
    if (!raw) return "";
    const mapped = USAGE_RENAME_MAP[raw.toLowerCase()];
    return mapped || raw;
  };
  const normalizeUsageOption = (option) => {
    if (!option || typeof option !== "object") return null;
    const baseLabel =
      (typeof option.label === "string" && option.label.trim()) ||
      (typeof option.value === "string" && option.value.trim()) ||
      "";
    const label = simplifyUsageLabel(baseLabel);
    if (!label) return null;
    return {
      ...option,
      value: label,
      label,
    };
  };
  const FALLBACK_USAGE_OPTIONS = RAW_FALLBACK_USAGE_OPTIONS.map(normalizeUsageOption).filter(Boolean);
  let toneOptionData = [...FALLBACK_TONE_DATA];
  let usageOptionData = [...FALLBACK_USAGE_OPTIONS];

  const deriveToneOptions = (guide) => {
    const playbooks = guide?.structuredGuide?.tonePlaybooks;
    if (!Array.isArray(playbooks)) return [];
    return playbooks
      .map((entry) => {
        const tone = typeof entry?.tone === "string" ? entry.tone.trim() : "";
        if (!tone) return null;
        const label = simplifyToneLabel(tone);
        if (!label) return null;
        const impact = typeof entry.impact === "string" ? entry.impact.trim() : "";
        const bestFor = Array.isArray(entry.bestFor)
          ? entry.bestFor
              .map((item) => (typeof item === "string" ? item.trim() : ""))
              .filter(Boolean)
              .slice(0, 3)
          : [];
        return {
          value: label,
          label,
          impact,
          bestFor,
        };
      })
      .filter(Boolean);
  };

  const deriveUsageOptions = (guide) => {
    if (!guide) return [];
    const structured = guide?.structuredGuide?.usagePlaybooks;
    if (Array.isArray(structured) && structured.length) {
      return structured
        .map((entry) => {
          const label = typeof entry?.label === "string" ? entry.label.trim() : "";
          const value = typeof entry?.value === "string" ? entry.value.trim() : label;
          if (!value) return null;
          return normalizeUsageOption({
            value,
            label: label || value,
            description: typeof entry.description === "string" ? entry.description.trim() : "",
            focus: Array.isArray(entry.focus)
              ? entry.focus
                  .map((item) => (typeof item === "string" ? item.trim() : ""))
                  .filter(Boolean)
              : [],
          });
        })
        .filter(Boolean);
    }
    const collected = [];
    const visit = (node) => {
      if (!node || typeof node !== "object") return;
      if (node.materials && typeof node.materials === "object") {
        Object.values(node.materials).forEach((group) => {
          if (!Array.isArray(group)) return;
          group.forEach((item) => {
            if (!item || typeof item.material !== "string") return;
            const label = item.material.trim();
            if (!label) return;
            const normalized = normalizeUsageOption({
              value: label,
              label,
              description: typeof item.definition === "string" ? item.definition.trim() : "",
              focus: Array.isArray(item.purpose)
                ? item.purpose
                    .map((entry) => (typeof entry === "string" ? entry.trim() : ""))
                    .filter(Boolean)
                : [],
            });
            if (normalized) {
              collected.push(normalized);
            }
          });
        });
      }
      if (Array.isArray(node.children)) {
        node.children.forEach(visit);
      }
    };
    visit(guide);
    return collected;
  };

  const mergeUsageOptions = (derived) => {
    const combined = [];
    const pushUnique = (option) => {
      const normalized = normalizeUsageOption(option);
      if (!normalized || typeof normalized.value !== "string") return;
      const value = normalized.value.trim();
      if (!value) return;
      const key = value.toLowerCase();
      if (combined.some((item) => item.value.toLowerCase() === key)) return;
      combined.push({
        value,
        label: normalized.label || value,
        description: normalized.description || "",
        focus: Array.isArray(normalized.focus) ? normalized.focus.filter(Boolean) : [],
      });
    };
    derived.forEach(pushUnique);
    FALLBACK_USAGE_OPTIONS.forEach(pushUnique);
    return combined.slice(0, 12);
  };

  const ensureToneSelectionValidity = () => {
    const current = getToneSelections();
    if (!current.length) return;
    const allowed = new Set(toneOptionData.map((item) => item.value));
    const filtered = current.filter((tone) => allowed.has(tone));
    if (filtered.length !== current.length) {
      setToneSelections(filtered);
    }
  };

  const ensureUsageSelectionValidity = () => {
    if (!filterSelections.element) return;
    const allowed = new Set(usageOptionData.map((item) => item.value));
    if (!allowed.has(filterSelections.element)) {
      delete filterSelections.element;
    }
  };

  const getToneMetaByValue = (value) =>
    toneOptionData.find((item) => item.value === value) || null;
  const getUsageMetaByValue = (value) =>
    usageOptionData.find((item) => item.value === value) || null;

  const shortenHelperText = (text) => {
    const clean = String(text || "").trim();
    if (!clean) return "";
    const withoutLead = clean
      .replace(
        /^(Use|Keep|Explain|Provide|Offer|Make|Add|Focus on|Highlight|Remember|Ensure|Avoid|Encourage|Maintain|Share|Deliver|Emphasize|Support)\b[\s,:-]*/i,
        ""
      )
      .trim();
    const tightened = withoutLead
      .replace(/\b(make sure to|be sure to|try to|aim to|you should|you must)\b/gi, "")
      .replace(/\b(please|really|just)\b/gi, "")
      .replace(/\b(your|their)\s+(users?|audience|customers?)\b/gi, "$2")
      .replace(/\s{2,}/g, " ")
      .trim();
    const candidate = tightened || withoutLead || clean;
    return candidate.replace(/[.:;]+$/, "").trim();
  };

  const updateContextHints = () => {
    if (!usageContextInput) return;
    const selectedUsage = getUsageMetaByValue(filterSelections.element);
    const selectedTone = getToneMetaByValue(getToneSelections()[0]);

    const helperChunks = [];
    const addHelper = (value) => {
      const clean = shortenHelperText(value);
      if (clean) {
        helperChunks.push(clean);
      }
    };

    addHelper(selectedUsage?.description);
    if (selectedUsage?.focus?.length) {
      addHelper(selectedUsage.focus.slice(0, 2).join(", "));
    }
    addHelper(selectedTone?.impact);
    const reminders = (guidelineMeta.rewriteRequirements || [])
      .map((req) => shortenHelperText(req))
      .filter(Boolean)
      .slice(0, 3);
    if (reminders.length) {
      helperChunks.push(reminders.join(" · "));
    }

    const helperLines = helperChunks.slice(0, 3);
    if (!helperLines.length) {
      updateContextPlaceholder(DEFAULT_CONTEXT_PLACEHOLDER, DEFAULT_PLACEHOLDER_LINES);
      return;
    }
    updateContextPlaceholder(helperLines.join("\n"), helperLines.length);
  };

  const toneOptionList = document.getElementById("toneOptionList");
  const CHIP_ICONS = Object.freeze({
    add: "data:image/svg+xml,%3Csvg%20width%3D%2716%27%20height%3D%2716%27%20viewBox%3D%270%200%2016%2016%27%20fill%3D%27none%27%20xmlns%3D%27http%3A//www.w3.org/2000/svg%27%3E%3Cpath%20d%3D%27M8%2016C12.4183%2016%2016%2012.4183%2016%208C16%203.58172%2012.4183%200%208%200C3.58172%200%200%203.58172%200%208C0%2012.4183%203.58172%2016%208%2016Z%27%20fill%3D%27%2300B0FF%27/%3E%3Cpath%20d%3D%27M11.4287%209.13869C12.0599%209.13869%2012.5716%208.62701%2012.5716%207.99583C12.5716%207.36465%2012.0599%206.85297%2011.4287%206.85297L9.14291%206.85297V4.56717C9.14291%203.93599%208.63124%203.42432%208.00005%203.42432C7.36887%203.42432%206.8572%203.93599%206.8572%204.56717V6.85297H4.57157C3.94039%206.85297%203.42871%207.36465%203.42871%207.99583C3.42871%208.62701%203.94039%209.13869%204.57157%209.13869H6.8572V11.4243C6.8572%2012.0555%207.36887%2012.5672%208.00005%2012.5672C8.63124%2012.5672%209.14291%2012.0555%209.14291%2011.4243V9.13869H11.4287Z%27%20fill%3D%27white%27/%3E%3C/svg%3E",
    remove: "data:image/svg+xml,%3Csvg%20width%3D%2716%27%20height%3D%2716%27%20viewBox%3D%270%200%2016%2016%27%20fill%3D%27none%27%20xmlns%3D%27http%3A//www.w3.org/2000/svg%27%3E%3Cpath%20d%3D%27M0%208C0%2012.4183%203.58172%2016%208%2016C12.4183%2016%2016%2012.4183%2016%208C16%203.58172%2012.4183%200%208%200C3.58172%200%200%203.58172%200%208Z%27%20fill%3D%27%2300B0FF%27/%3E%3Cpath%20d%3D%27M9.62055%2011.2326C10.0669%2011.6789%2010.7905%2011.6789%2011.2368%2011.2326C11.6831%2010.7863%2011.6831%2010.0627%2011.2368%209.61636L9.62049%208.00005L11.2368%206.38375C11.6831%205.93744%2011.6831%205.21382%2011.2368%204.7675C10.7905%204.32119%2010.0669%204.32119%209.62055%204.7675L8.00425%206.38381L6.38807%204.76763C5.94175%204.32131%205.21814%204.32131%204.77182%204.76763C4.32551%205.21394%204.32551%205.93756%204.77182%206.38387L6.38801%208.00005L4.77182%209.61624C4.32551%2010.0626%204.32551%2010.7862%204.77182%2011.2325C5.21814%2011.6788%205.94175%2011.6788%206.38807%2011.2325L8.00425%209.6163L9.62055%2011.2326Z%27%20fill%3D%27white%27/%3E%3C/svg%3E",
  });

  const renderToneChips = () => {
    if (!toneOptionList) return;
    const selectedTones = getToneSelections();
    const optionsToRender = toneOptionData.slice(0, 12);
    toneOptionList.innerHTML = optionsToRender
      .map((tone) => {
        if (!tone?.value) return "";
        const value = tone.value;
        const label = tone.label || value;
        const isSelected = selectedTones.includes(value);
        const isDisabled = !isSelected && selectedTones.length >= MAX_TONE_SELECTIONS;
        const iconSrc = isSelected ? CHIP_ICONS.remove : CHIP_ICONS.add;
        return `<button type="button" class="tone-chip${isSelected ? " is-selected" : ""}" data-tone="${escapeHtml(
          value
        )}" aria-pressed="${isSelected}" ${isDisabled ? "disabled" : ""}>
          <span class="tone-chip-label">${escapeHtml(label)}</span>
          <img class="tone-chip-icon" src="${iconSrc}" alt="" aria-hidden="true" />
        </button>`;
      })
      .filter(Boolean)
      .join("");
    updateContextHints();
  };

  toneOptionList?.addEventListener("click", (event) => {
    const chip = event.target.closest(".tone-chip");
    if (!chip) return;
    const tone = chip.getAttribute("data-tone");
    if (!tone) return;
    if (chip.disabled) return;
    const current = getToneSelections();
    if (current.includes(tone)) {
      setToneSelections(current.filter((item) => item !== tone));
    } else if (current.length < MAX_TONE_SELECTIONS) {
      setToneSelections([...current, tone]);
    }
    renderToneChips();
  });

  const renderElementChips = () => {
    if (!elementOptionList) return;
    const selected = filterSelections.element || "";
    const optionsToRender = usageOptionData.slice(0, 12);
    elementOptionList.innerHTML = optionsToRender
      .map((option) => {
        if (!option?.value) return "";
        const value = option.value;
        const label = option.label || value;
        const isSelected = selected === value;
        return `<button type="button" class="element-chip${isSelected ? " is-selected" : ""}" data-element="${escapeHtml(
          value
        )}" aria-pressed="${isSelected}">
          <span class="element-chip-label">${escapeHtml(label)}</span>
        </button>`;
      })
      .filter(Boolean)
      .join("");
    updateContextHints();
  };
  elementOptionList?.addEventListener("click", (event) => {
    const chip = event.target.closest(".element-chip");
    if (!chip) return;
    const value = chip.getAttribute("data-element");
    if (!value) return;
    filterSelections.element = filterSelections.element === value ? "" : value;
    if (!filterSelections.element) {
      delete filterSelections.element;
    }
    renderElementChips();
  });

  const applyGuidelineMeta = (guide) => {
    const toneData = deriveToneOptions(guide);
    toneOptionData = toneData.length ? toneData : [...FALLBACK_TONE_DATA];
    const usageData = mergeUsageOptions(deriveUsageOptions(guide));
    usageOptionData = usageData.length ? usageData : [...FALLBACK_USAGE_OPTIONS];
    const rewritePrompt = guide?.rewritePrompt || {};
    guidelineMeta.rewriteOverview =
      typeof rewritePrompt.overview === "string" ? rewritePrompt.overview.trim() : "";
    guidelineMeta.rewriteRequirements = Array.isArray(rewritePrompt.requirements)
      ? rewritePrompt.requirements
          .map((item) => (typeof item === "string" ? item.trim() : ""))
          .filter(Boolean)
      : [];
    ensureToneSelectionValidity();
    ensureUsageSelectionValidity();
    renderToneChips();
    renderElementChips();
    updateContextHints();
  };

  const LENGTH_MIN = Number(lengthSlider?.min ?? 12);
  const LENGTH_MAX = Number(lengthSlider?.max ?? 160);
  const LENGTH_THUMB_SIZE = 32;
  const LENGTH_SNAP_THRESHOLD = 8;
  const findLengthPreset = (value) => {
    if (!Array.isArray(LENGTH_PRESETS) || !LENGTH_PRESETS.length) return null;
    let closest = LENGTH_PRESETS[0];
    let diff = Math.abs(value - closest.value);
    for (let i = 1; i < LENGTH_PRESETS.length; i += 1) {
      const candidate = LENGTH_PRESETS[i];
      const distance = Math.abs(value - candidate.value);
      if (distance < diff) {
        closest = candidate;
        diff = distance;
      }
    }
    return closest;
  };

  const getSnappedLengthValue = (value) => {
    const preset = findLengthPreset(value);
    if (!preset) return null;
    const distance = Math.abs(value - preset.value);
    if (distance <= LENGTH_SNAP_THRESHOLD) return preset.value;
    return null;
  };

  const renderLengthPresetMarkers = () => {
    if (!lengthSlider || !lengthPresetMarkers) return;
    const min = LENGTH_MIN;
    const max = LENGTH_MAX;
    lengthPresetMarkers.innerHTML = LENGTH_PRESETS.map((preset) => {
      const percent = Math.min(Math.max((preset.value - min) / (max - min), 0), 1) * 100;
      return `<button type="button" class="length-preset" data-value="${preset.value}" style="left:${percent}%">
        <span class="sr-only">${preset.label}</span>
      </button>`;
    }).join("");
  };

  const renderLengthPresetLabels = () => {
    if (!lengthPresetLabels) return;
    lengthPresetLabels.innerHTML = LENGTH_PRESETS.map(
      (preset) => `<span data-value="${preset.value}">${preset.label}</span>`
    ).join("");
  };

  const updateLengthPresetActiveStates = (value) => {
    const markers = lengthPresetMarkers?.querySelectorAll(".length-preset");
    const labels = lengthPresetLabels?.querySelectorAll("span");
    markers?.forEach((marker) => {
      const markerValue = Number(marker.getAttribute("data-value"));
      marker.classList.toggle("active", markerValue === value);
    });
    labels?.forEach((label) => {
      const labelValue = Number(label.getAttribute("data-value"));
      label.classList.toggle("active", labelValue === value);
    });
  };

  const updateLengthUI = (value) => {
    if (value < 12 && lengthSlider) {
      lengthSlider.value = "12";
      value = 12;
    }
    if (lengthValueEl) {
      const preset = findLengthPreset(value);
      const suffix = preset ? ` · ${preset.label}` : "";
      lengthValueEl.textContent = `${value} characters${suffix}`;
    }
    if (!lengthSlider || !lengthFill) return;
    const percent = Math.min(
      Math.max((value - LENGTH_MIN) / (LENGTH_MAX - LENGTH_MIN), 0),
      1
    );
    const trackWidth = lengthSlider.offsetWidth || 0;
    if (!trackWidth) {
      lengthFill.style.width = `${LENGTH_THUMB_SIZE}px`;
      return;
    }
    const knobRadius = LENGTH_THUMB_SIZE / 2;
    const availableWidth = Math.max(trackWidth - LENGTH_THUMB_SIZE, 0);
    const knobCenter = knobRadius + availableWidth * percent;
    const fillWidth = knobCenter + knobRadius;
    lengthFill.style.width = `${Math.min(fillWidth, trackWidth)}px`;
    updateLengthPresetActiveStates(findLengthPreset(value)?.value || NaN);
  };
  const setLengthPresetValue = (value) => {
    if (!lengthSlider) return;
    lengthSlider.value = String(value);
    filterSelections.length = value;
    updateLengthUI(value);
  };
  lengthSlider?.addEventListener("input", (event) => {
    const value = Number(event.target.value);
    filterSelections.length = value;
    updateLengthUI(value);
  });
  const commitLengthSliderValue = () => {
    if (!lengthSlider) return;
    const value = Number(lengthSlider.value);
    if (Number.isNaN(value)) return;
    const snappedValue = getSnappedLengthValue(value);
    if (snappedValue !== null) {
      setLengthPresetValue(snappedValue);
      return;
    }
    filterSelections.length = value;
    updateLengthUI(value);
  };
  lengthSlider?.addEventListener("change", commitLengthSliderValue);
  lengthPresetMarkers?.addEventListener("click", (event) => {
    const button = event.target.closest(".length-preset");
    if (!button) return;
    const value = Number(button.getAttribute("data-value"));
    if (Number.isNaN(value)) return;
    setLengthPresetValue(value);
  });
  lengthPresetLabels?.addEventListener("click", (event) => {
    const label = event.target.closest("span[data-value]");
    if (!label) return;
    const value = Number(label.getAttribute("data-value"));
    if (Number.isNaN(value)) return;
    setLengthPresetValue(value);
  });
  window.addEventListener("resize", () => {
    if (lengthSlider) {
      updateLengthUI(Number(lengthSlider.value));
    }
    if (usageContextInput && !usageContextInput.value.trim().length) {
      updateContextHints();
    }
  });

  const setGuidelineIndicator = (state, text) => {
    if (!guidelineStatus || !guidelineStatusText) return;
    guidelineStatus.classList.remove("loaded", "fallback", "error");
    guidelineStatus.classList.add(state);
    guidelineStatusText.textContent = text;
  };

  let guidelineReference = null;
  const getGuidelinePayload = () => {
    if (guidelineReference) return guidelineReference;
    setGuidelineIndicator("fallback", "Using fallback style guide.");
    return fallbackGuideline;
  };
  const buildGuidelinePayload = () => {
    const base = getGuidelinePayload();
    const payload = base && typeof base === "object" ? { ...base } : {};
    const toneSelections = getToneSelections();
    if (toneSelections.length === 1) {
      payload.tonePreference = toneSelections[0];
    } else if (toneSelections.length > 1) {
      payload.tonePreference = toneSelections;
    } else {
      delete payload.tonePreference;
    }
    const otherFilters = {};
    if (filterSelections.element) {
      otherFilters.element = filterSelections.element;
    }
    const lengthFilter = filterSelections.length;
    if (typeof lengthFilter === "number" && !Number.isNaN(lengthFilter)) {
      otherFilters.length = lengthFilter;
    }
    if (Object.keys(otherFilters).length) {
      payload.styleFilters = otherFilters;
    } else {
      delete payload.styleFilters;
    }
    if (usageContextValue) {
      payload.usageContext = usageContextValue;
    } else {
      delete payload.usageContext;
    }
    return payload;
  };
  setGuidelineIndicator("fallback", "Loading style guide…");

  const resolveTargetOrigin = () => {
    try {
      const ref = document.referrer;
      if (ref && ref !== "null") {
        return new URL(ref).origin;
      }
    } catch (err) {
      console.warn("Could not parse parent origin:", err);
    }
    return "https://www.figma.com";
  };

  const targetOrigin = resolveTargetOrigin();

  const postToPlugin = (pluginMessage) => {
    if (!window.parent || window.parent === window) {
      console.warn("Figma host unavailable; skipping postMessage", pluginMessage);
      return;
    }
    window.parent.postMessage({ pluginMessage }, targetOrigin);
  };
  const applySuggestionText = (text) => {
    if (typeof text !== "string" || !text.trim()) return;
    if (inputField) {
      inputField.value = text;
      inputField.dispatchEvent(new Event("input"));
    }
    postToPlugin({ type: "apply-text", text });
  };
  const activateSuggestionCard = (target) => {
    const card = target instanceof HTMLElement ? target : null;
    if (!card || card.classList.contains("skeleton")) return;
    const text = card.getAttribute("data-text") || "";
    if (!text.trim()) return;
    applySuggestionText(text);
  };
  const handleSuggestionCardClick = (event) => {
    if (!event?.currentTarget) return;
    event.preventDefault();
    activateSuggestionCard(event.currentTarget);
  };
  const handleSuggestionCardKeydown = (event) => {
    if (!event?.currentTarget) return;
    const key = event.key;
    if (key === "Enter" || key === " ") {
      event.preventDefault();
      activateSuggestionCard(event.currentTarget);
    }
  };

  const renderEmptyState = () => {
    clearSuggestionRevealTimers();
    suggestionBody.className = "suggestion-body centered";
    suggestionBody.innerHTML = `
      <div class="empty-arrow">↑</div>
      <p>Select a text layer in Figma and click Rewrite to generate copy suggestions</p>
    `;
  };

  const renderLoading = (text = DEFAULT_LOADING_TEXT, skeletonCount = MIN_SUGGESTIONS) => {
    showSuggestionsScreen();
    renderSkeletonPlaceholders(skeletonCount);
    if (rewriteShimmerText && typeof text === "string" && text.trim()) {
      rewriteShimmerText.textContent = text;
    }
  };

  const renderStatus = (text) => {
    clearSuggestionRevealTimers();
    suggestionBody.className = "suggestion-body centered";
    suggestionBody.innerHTML = `<p>${text}</p>`;
  };

  const renderError = (text) => {
    clearSuggestionRevealTimers();
    suggestionBody.className = "suggestion-body centered error";
    suggestionBody.innerHTML = `<p>${text || "Something went wrong. Try again in a bit."}</p>`;
  };

  const renderSuggestions = (items) => {
    if (!items.length) {
      renderStatus("No response.");
      return;
    }

    const { list, cards } = renderSkeletonPlaceholders(items.length);
    if (!cards.length || !list) {
      skeletonActive = false;
      skeletonVisibleSince = 0;
      const fallbackCards = items
        .map(
          (item) => `
        <article class="suggestion-card">
          <p>${item.text}</p>
          <div class="suggestion-meta">
            <span>${item.tones.join(", ")}</span>
            <span class="suggestion-dot" aria-hidden="true">·</span>
            <span class="suggestion-char">${formatCharCount(item.text.length)}</span>
          </div>
        </article>`
        )
        .join("");
      suggestionBody.className = "suggestion-body";
      suggestionBody.innerHTML = `<div class="suggestions-list">${fallbackCards}</div>`;
      return;
    }
    scheduleSuggestionReveal(cards, items, list);
  };

  const stripFormatting = (line) =>
    line
      .replace(/[*_`]/g, "")
      .replace(/^\d+[\.)-]*\s*/, "")
      .replace(/^[-•*]+\s*/, "")
      .replace(/\s+/g, " ")
      .trim();
  const stripTrailingCharCount = (text) => {
    if (!text) return text;
    return text.replace(/\s*\(\s*~?\d+\s*(?:char(?:s)?|character(?:s)?)\s*\)\s*$/i, "").trim();
  };

  const looksLikeMeta = (line) => {
    const lower = line.toLowerCase();
    if (!lower) return true;
    if (lower.length <= 2) return true;
    const metaPrefixes = [
      "here are",
      "here's",
      "these are",
      "please note",
      "okay, i'm",
      "alright, i'm",
      "i'm ready",
      "let me",
      "i will",
      "i can",
      "remember:",
      "for reference",
      "guideline:",
      "dialog:",
      "instruction:",
    ];
    if (metaPrefixes.some((p) => lower.startsWith(p))) return true;
    if (/^option\s*\d+/i.test(lower)) return true;
    if (lower.startsWith("option ") || lower.startsWith("option:")) return true;
    if (lower.includes("option ") && lower.endsWith(":")) return true;
    if (lower.includes("dialog") || lower.includes("instruction")) return true;
    if (lower.endsWith(":") && (lower.includes("requirement") || lower.includes("suggestion"))) return true;
    if (lower.includes("i've provided") || lower.includes("i have provided")) return true;
    if (lower.includes("below are") || lower.includes("as requested")) return true;
    return false;
  };

  const expandNumberedItems = (text) => {
    if (!/\d+[\.)-]/.test(text)) return null;
    const segments = text
      .split(/\d+[\.)-]\s*/g)
      .map((segment) => segment.trim())
      .filter(Boolean);
    return segments.length >= 2 ? segments : null;
  };

  const buildSuggestions = (raw) => {
    if (!raw) return [];

    const expandedRaw = raw.replace(/(\d+[\.)-])/g, "\n$1");
    let blocks = expandedRaw.split(/\n{2,}/);
    if (blocks.length === 1) {
      blocks = expandedRaw.split(/\n+/);
    }

    const normalized = blocks
      .map((block) => stripFormatting(block))
      .filter(Boolean)
      .filter((block) => !looksLikeMeta(block));

    const flattened = normalized.flatMap((text) => {
      const expanded = expandNumberedItems(text);
      return expanded && expanded.length ? expanded : [text];
    });

    const unique = [];
    const seen = new Set();
    flattened.forEach((text) => {
      const clean = stripTrailingCharCount(stripFormatting(text));
      if (!clean) return;
      const key = clean.toLowerCase();
      if (!seen.has(key)) {
        seen.add(key);
        unique.push(clean);
      }
    });

    return unique.slice(0, MIN_SUGGESTIONS).map((text, idx) => ({
      text,
      score: Math.max(80, 95 - idx * 2),
      tones: toneFallbacks[idx % toneFallbacks.length],
    }));
  };

  const applySelectionText = (text) => {
    if (!text) return;
    inputField.value = text;
    inputField.dispatchEvent(new Event("input"));
  };

  renderToneChips();
  renderElementChips();
  renderLengthPresetMarkers();
  renderLengthPresetLabels();
  updateContextHints();
  if (lengthSlider) {
    updateLengthUI(Number(lengthSlider.value));
    filterSelections.length = Number(lengthSlider.value);
  }

  usageContextInput?.addEventListener("input", () => {
    usageContextValue = usageContextInput.value.trim();
    resizeContextInput();
    updateContextHints();
  });

  btnRewrite.onclick = async () => {
    const text = inputField.value.trim();
    if (!text) {
      alert("Please enter some text.");
      return;
    }
    const guidelinePayload = buildGuidelinePayload();
    setRewriteLoadingState(true);
    renderLoading();

    const key = geminiKeyInput ? geminiKeyInput.value.trim() : "";
    if (!key) {
      postToPlugin({ type: "load-key" });
      renderLoading("Loading saved key…");
      window.__pendingText = text;
      window.__pendingGuideline = guidelinePayload;
      return;
    }

    delete window.__pendingGuideline;
    postToPlugin({ type: "rewrite", key, text, guideline: guidelinePayload });
  };

  inputField.addEventListener("input", () => {
    const hasText = Boolean(inputField.value.trim());
    updateRewriteButtonState();
    updateInputCharCount();
    resizeRewriteInput();
    if (!hasText && !window.__pendingText) {
      renderEmptyState();
    }
  });

  // settings save/load
  saveKeyBtn.onclick = () => {
    const key = geminiKeyInput.value.trim();
    postToPlugin({ type: "save-key", key });
    saveStatus.textContent = "Saving…";
  };
  loadKeyBtn.onclick = () => {
    postToPlugin({ type: "load-key" });
    saveStatus.textContent = "Loading…";
  };

  // messages from main
  onmessage = (event) => {
    const msg = event.data.pluginMessage;

    if (msg?.type === "guideline-default") {
      if (msg.error) {
        guidelineReference = null;
        setGuidelineIndicator("error", "Couldn't load style guide. Using fallback.");
        toneOptionData = [...FALLBACK_TONE_DATA];
        usageOptionData = [...FALLBACK_USAGE_OPTIONS];
        guidelineMeta.rewriteOverview = "";
        guidelineMeta.rewriteRequirements = [];
        renderToneChips();
        renderElementChips();
        updateContextHints();
      } else if (msg.guideline) {
        guidelineReference = msg.guideline;
        setGuidelineIndicator("loaded", "Using structured style guide.");
        applyGuidelineMeta(msg.guideline);
      } else {
        guidelineReference = null;
        setGuidelineIndicator("fallback", "Using fallback style guide.");
        toneOptionData = [...FALLBACK_TONE_DATA];
        usageOptionData = [...FALLBACK_USAGE_OPTIONS];
        guidelineMeta.rewriteOverview = "";
        guidelineMeta.rewriteRequirements = [];
        renderToneChips();
        renderElementChips();
        updateContextHints();
      }
      return;
    }

    if (msg?.type === "key-saved") {
      saveStatus.textContent = msg.error ? ("Save failed: " + msg.error) : "Key saved.";
      if (!msg.error && typeof msg.key === "string") {
        geminiKeyInput.value = msg.key;
      }
      return;
    }
    if (msg?.type === "key-loaded") {
      if (msg.error) {
        saveStatus.textContent = "Load failed: " + msg.error;
        setRewriteLoadingState(false);
        if (window.__pendingText) {
          showSuggestionsScreen();
          renderStatus("Couldn't load your API key. Add it in Settings to try again.");
          delete window.__pendingText;
          delete window.__pendingGuideline;
          activate("settings");
        }
        return;
      }

      const loadedKeyRaw = typeof msg.key === "string" ? msg.key : "";
      const loadedKey = loadedKeyRaw.trim();

      geminiKeyInput.value = loadedKeyRaw;
      saveStatus.textContent = loadedKey ? "Key loaded." : "No key saved yet.";

      if (window.__pendingText) {
        if (loadedKey) {
          const text = window.__pendingText;
          const guide = window.__pendingGuideline || buildGuidelinePayload();
          delete window.__pendingText;
          delete window.__pendingGuideline;
          postToPlugin({ type: "rewrite", key: loadedKey, text, guideline: guide });
          setRewriteLoadingState(true);
          renderLoading();
        } else {
          setRewriteLoadingState(false);
          showSuggestionsScreen();
          renderStatus("Add your Gemini API key in Settings to generate copy suggestions.");
          delete window.__pendingText;
          delete window.__pendingGuideline;
          activate("settings");
        }
      }
      return;
    }
    if (msg?.type === "error") {
      const errText =
        typeof msg.error === "string"
          ? msg.error
          : msg && msg.error && msg.error.message
          ? String(msg.error.message)
          : "Unknown error.";
      console.error("Gemini rewrite error:", msg.error);
      setRewriteLoadingState(false);
      activate("rewrite");
      showSuggestionsScreen();
      renderError("Generation failed: " + errText);
      return;
    }
    if (msg?.type === "selection-text") {
      if (typeof msg.text === "string" && msg.text.length) {
        applySelectionText(msg.text);
      }
      return;
    }
    if (msg?.type === "rewrite-done") {
      const output = typeof msg.output === "string" ? msg.output.trim() : "";
      setRewriteLoadingState(false);
      showSuggestionsScreen();
      if (msg.error) {
        renderError(output);
      } else {
        const suggestions = buildSuggestions(output);
        if (suggestions.length >= MIN_SUGGESTIONS) {
          renderSuggestions(suggestions);
        } else {
          renderError(
            suggestions.length
              ? `Only ${suggestions.length}/${MIN_SUGGESTIONS} suggestions returned. Please try again.`
              : output || "No response."
          );
        }
      }
      activate("rewrite");
      return;
    }
  };

  // auto-load key when opening settings
  tabs.settings.tab.addEventListener("click", ()=> {
    postToPlugin({ type: "load-key" });
    saveStatus.textContent = "Loading…";
  });

  updateInputCharCount();
  resizeRewriteInput();
  resizeContextInput();
  renderEmptyState();
  postToPlugin({ type: "request-guideline" });
</script>
