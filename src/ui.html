<!doctype html>
<meta charset="utf-8" />
<style>
  :root {
    --bg: #fff;
    --muted: #f5f5f7;
    --line: #e6e6e6;
    --primary: #7f56d9;
    --text: #111827;
    --subtle: #6b7280;
  }
  *,
  *::before,
  *::after {
    box-sizing: border-box;
  }
  html,
  body {
    font: 14px/1.4 "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
    margin: 0;
    width: 100%;
    max-width: 100%;
    background: var(--bg);
    color: var(--text);
    overflow-x: hidden;
  }
  .tabs {
    display: flex;
    gap: 6px;
    padding: 4px;
    margin: 12px;
    border-radius: 8px;
    background: rgba(0, 0, 0, 0.05);
  }
  .tab {
    flex: 1;
    text-align: center;
    padding: 9px 16px;
    border-radius: 8px;
    cursor: pointer;
    user-select: none;
    font-family: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
    font-weight: 500;
    font-size: 15px;
    line-height: 18px;
    color: #788494;
    transition: color 0.15s ease, background 0.15s ease, box-shadow 0.15s ease;
  }
  .tab.active {
    background: #fff;
    color: #2d333a;
  }
  .panel {
    padding: 12px;
    display: none;
  }
  .panel.active {
    display: block;
  }
  .rewrite-screen {
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.25s ease;
    pointer-events: none;
  }
  .rewrite-screen.active {
    opacity: 1;
    visibility: visible;
    pointer-events: auto;
  }
  .rewrite-screen[hidden] {
    display: none !important;
  }
  .rewrite-screen.loading-screen {
    display: flex;
  }
  .loading-screen {
    min-height: 320px;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 16px;
    text-align: center;
    padding: 32px 16px;
  }
  .loading-screen p {
    margin: 0;
    font-size: 16px;
    line-height: 22px;
    color: #111827;
    font-weight: 500;
    white-space: pre-line;
  }
  .loading-illustration {
    width: 112px;
    height: 112px;
    border-radius: 50%;
    background: #e3f2ff;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .loading-illustration svg {
    width: 90px;
    height: 90px;
    display: block;
  }
  .back-button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    border: none;
    background: transparent;
    cursor: pointer;
    padding: 4px;
    border-radius: 999px;
  }
  .back-button svg {
    width: 24px;
    height: 24px;
    display: block;
  }
  .back-button:focus-visible {
    outline: 2px solid #7f56d9;
    outline-offset: 2px;
  }
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    border: 0;
  }
  .suggestions-screen {
    padding: 16px 0 16px;
  }
  .suggestions-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 16px;
  }
  .suggestions-header h2 {
    margin: 0;
    color: #000;
    font-size: 18px;
    font-style: normal;
    font-weight: 600;
    line-height: 27px;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .field-header {
    display: flex;
    align-items: flex-end;
    justify-content: space-between;
    margin-bottom: 6px;
  }
  .field-label {
    color: #525b65;
    font-size: 14px;
    line-height: 20px;
    font-weight: 500;
  }
  /* length controls removed */
  textarea,
  input[type="text"] {
    width: 100%;
    padding: 12px;
    border: 1px solid #f5f5f5;
    border-radius: 4px;
    font-family: inherit;
    font-size: 14px;
    box-sizing: border-box;
    transition: border-color 0.15s ease;
  }
  textarea {
    resize: none;
    min-height: 52px;
    overflow-y: hidden;
    margin: 0;
  }
  textarea::placeholder,
  input[type="text"]::placeholder {
    color: #788494;
    line-height: 20px;
  }
  textarea:focus,
  input[type="text"]:focus {
    border-color: #00b0ff;
    outline: none;
  }
  .guideline-status {
    margin: 8px 0 0;
    font-size: 12px;
    color: var(--subtle);
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .guideline-status .status-dot {
    width: 8px;
    height: 8px;
    border-radius: 999px;
    background: #d1d5db;
  }
  .guideline-status.loaded .status-dot {
    background: #34d399;
  }
  .guideline-status.fallback .status-dot {
    background: #fbbf24;
  }
  .guideline-status.error .status-dot {
    background: #f87171;
  }
  .rewrite-btn {
    width: 100%;
    margin-top: 16px;
    padding: 12px;
    border: 0;
    border-radius: 12px;
    background: #00b0ff;
    color: #fff;
    font-weight: 600;
    font-size: 14px;
    line-height: 17px;
    letter-spacing: 1px;
    text-transform: uppercase;
    cursor: pointer;
    text-align: center;
    position: relative;
    overflow: hidden;
  }
  .rewrite-btn:disabled:not(.is-loading) {
    cursor: default;
    opacity: 0.65;
  }
  .rewrite-label,
  .rewrite-shimmer {
    display: block;
    transition: opacity 0.2s ease;
  }
  .rewrite-shimmer {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: linear-gradient(110deg, rgba(255,255,255,0.4), #fff, rgba(255,255,255,0.4));
    background-size: 200% auto;
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    animation: shimmerText 1.4s linear infinite;
    font-weight: 700;
    letter-spacing: 0.08em;
    opacity: 0;
    pointer-events: none;
  }
  .rewrite-btn.is-loading .rewrite-label {
    opacity: 0;
  }
  .rewrite-btn.is-loading .rewrite-shimmer {
    opacity: 1;
  }
  @keyframes shimmerText {
    0% {
      background-position: -100% 0;
    }
    100% {
      background-position: 200% 0;
    }
  }
  .suggestions {
    margin-top: 0;
    border: 0;
    padding-top: 0;
  }
  .suggestion-body {
    min-height: 0;
    padding: 0;
    color: var(--subtle);
    display: flex;
    flex-direction: column;
    gap: 10px;
  }
  .suggestion-note {
    border-radius: 10px;
    border: 1px solid #fde1c3;
    background: #fff8f1;
    color: #9a3412;
    font-size: 13px;
    line-height: 18px;
    padding: 10px 12px;
  }
  .suggestion-body.centered {
    padding: 16px;
    min-height: 140px;
    justify-content: center;
    align-items: center;
    text-align: center;
    border-radius: 12px;
    background: var(--muted);
  }
  .suggestion-body.error {
    background: #fef2f2;
    color: #991b1b;
    border: 1px solid #fecaca;
  }
  .suggestion-body.centered .empty-arrow {
    font-size: 30px;
    color: #d1d5db;
  }
  .suggestions-list {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }
  .suggestion-card {
    border-radius: 12px;
    border: 1px solid #f1f1f3;
    background: #f8f8fa;
    padding: 12px 14px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    color: #1f2933;
    transition: opacity 0.3s ease, transform 0.3s ease;
    cursor: default;
  }
  .suggestion-card p {
    margin: 0;
    font-size: 14px;
  }
  .suggestion-meta {
    display: flex;
    align-items: flex-start;
    gap: 4px;
    align-self: stretch;
    color: #788494;
    font-family: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
    font-size: 14px;
    font-style: normal;
    font-weight: 400;
    line-height: 20px;
  }
  .suggestion-dot {
    color: inherit;
  }
  .suggestion-card.is-interactive {
    cursor: pointer;
  }
  .suggestion-card.is-interactive:focus-visible {
    outline: 2px solid #00b0ff;
    outline-offset: 2px;
  }
  .suggestion-card.is-interactive:active {
    transform: translateY(1px);
  }
  .suggestions-list.is-loading .suggestion-card {
    opacity: 1;
  }
  .suggestion-card.skeleton {
    position: relative;
    overflow: hidden;
  }
  .suggestion-card.revealing {
    opacity: 0;
    transform: translateY(8px);
  }
  .suggestion-card.revealed {
    opacity: 1;
    transform: translateY(0);
  }
  .skeleton-block {
    background: #e0e0e0;
    position: relative;
    overflow: hidden;
    display: block;
  }
  .skeleton-block::before {
    content: "";
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(
      90deg,
      transparent 0%,
      rgba(255, 255, 255, 0.6) 50%,
      transparent 100%
    );
    animation: shimmer 1.5s infinite;
  }
  @keyframes shimmer {
    0% {
      left: -100%;
    }
    100% {
      left: 100%;
    }
  }
  .skeleton-line,
  .skeleton-pill {
    display: block;
    width: 100%;
    border-radius: 999px;
  }
  .skeleton-line {
    height: 12px;
    margin-bottom: 8px;
  }
  .skeleton-line.long {
    width: 90%;
  }
  .skeleton-line.short {
    width: 55%;
  }
  .skeleton-pill {
    height: 10px;
    width: 72px;
  }
  .skeleton-pill.short {
    width: 42px;
  }
  .skeleton-meta {
    display: flex;
    gap: 8px;
    align-items: center;
    margin-top: 6px;
  }
  @media (prefers-reduced-motion: reduce) {
    .skeleton-block::before {
      animation: none;
    }
  }
  .score-pill {
    background: #d1fae5;
    color: #0f5132;
    border-radius: 6px;
    padding: 2px 8px;
    font-weight: 600;
    font-size: 12px;
  }
  .row {
    display: flex;
    gap: 8px;
    align-items: center;
  }
  .status-text {
    margin-top: 8px;
    font-size: 12px;
    color: var(--subtle);
  }
  .muted-text {
    font-size: 12px;
    color: var(--subtle);
  }
  .context-field {
    margin-top: 24px;
  }
  .context-field label {
    display: block;
    margin-bottom: 8px;
    font-size: 14px;
    line-height: 20px;
    font-weight: 500;
    color: #525b65;
  }
  .context-area {
    width: 100%;
    border: 1px solid #f5f5f5;
    border-radius: 4px;
    background: #fff;
    padding: 12px;
    font-size: 14px;
    line-height: 20px;
    font-family: inherit;
    resize: none;
  }
  .context-area::placeholder {
    color: #94a3b8;
  }
  .char-counter {
    font-size: 12px;
    line-height: 18px;
    color: #788494;
  }
</style>

<div class="tabs">
  <div id="tab-rewrite" class="tab active">Rewrite</div>
  <div id="tab-settings" class="tab">Settings</div>
</div>

<div id="panel-rewrite" class="panel active">
  <div class="rewrite-screen-container">
    <div id="rewriteHome" class="rewrite-screen active">
      <div class="field-header">
        <label id="inputLabel" class="field-label" for="inputText">Enter copy</label>
        <div id="inputCharCount" class="char-counter">0 characters</div>
      </div>
      <textarea
        id="inputText"
        class="auto-textarea"
        rows="2"
        placeholder="Type your copy or select a text layer in figma"
      ></textarea>
      <!-- tone controls removed -->
      <div class="context-field">
        <label for="usageContextInput">Context and custom instructions</label>
        <textarea
          id="usageContextInput"
          class="context-area auto-textarea"
          rows="2"
          placeholder="Use on fuelling flow.&#10;Do not use word &ldquo;free&rdquo;."
        ></textarea>
      </div>

      <button id="rewrite" class="rewrite-btn" disabled aria-live="polite">
        <span class="rewrite-label">Rewrite</span>
        <span id="rewriteShimmerText" class="rewrite-shimmer" aria-hidden="true">Crafting copy…</span>
      </button>
    </div>

    <div id="suggestionsScreen" class="rewrite-screen suggestions-screen" hidden>
      <div class="suggestions-header">
        <button type="button" id="backToForm" class="back-button" aria-label="Back to rewrite form">
          <span class="sr-only">Back</span>
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
            <path d="M15.5303 4.46967C15.2641 4.2034 14.8474 4.1792 14.5538 4.39705L14.4697 4.46967L7.46967 11.4697C7.2034 11.7359 7.1792 12.1526 7.39705 12.4462L7.46967 12.5303L14.4697 19.5303C14.7626 19.8232 15.2374 19.8232 15.5303 19.5303C15.7966 19.2641 15.8208 18.8474 15.6029 18.5538L15.5303 18.4697L9.061 12L15.5303 5.53033C15.7966 5.26406 15.8208 4.8474 15.6029 4.55379L15.5303 4.46967Z" fill="#2d333a"/>
          </svg>
        </button>
        <h2>Suggestions</h2>
      </div>
      <section class="suggestions">
        <div id="suggestionBody" class="suggestion-body centered"></div>
      </section>
    </div>
  </div>
</div>

<div id="panel-settings" class="panel">
  <div id="guidelineStatus" class="guideline-status fallback">
    <span class="status-dot"></span>
    <span class="guideline-text">Loading style guide…</span>
  </div>
  <label>API key (Gemini)</label>
  <input id="apikey" type="text" placeholder="AIza..." />
  <div class="row">
    <button id="saveKey">Save key</button>
    <button id="loadKey">Load key</button>
  </div>
  <div id="saveStatus" style="margin-top:8px;color:#555;"></div>
</div>

<script>
  // tab switching
  const tabs = {
    rewrite: { tab: document.getElementById("tab-rewrite"), panel: document.getElementById("panel-rewrite") },
    settings:{ tab: document.getElementById("tab-settings"), panel: document.getElementById("panel-settings") },
  };
  function activate(name){
    Object.values(tabs).forEach(({tab,panel})=>{
      tab.classList.remove("active"); panel.classList.remove("active");
    });
    tabs[name].tab.classList.add("active"); tabs[name].panel.classList.add("active");
  }
  tabs.rewrite.tab.onclick=()=>activate("rewrite");
  tabs.settings.tab.onclick=()=>{
    activate("settings");
  };

  // rewrite flow
  const btnRewrite = document.getElementById("rewrite");
  const suggestionBody = document.getElementById("suggestionBody");
  const rewriteHomeScreen = document.getElementById("rewriteHome");
  const suggestionsScreen = document.getElementById("suggestionsScreen");
  const backToFormBtn = document.getElementById("backToForm");
  const rewriteShimmerText = document.getElementById("rewriteShimmerText");
  const screenViews = {
    home: rewriteHomeScreen,
    suggestions: suggestionsScreen,
  };
  const SCREEN_FADE_MS = 250;
  const viewHideTimers = new WeakMap();
  const cancelPendingHide = (view) => {
    const timerId = viewHideTimers.get(view);
    if (timerId) {
      clearTimeout(timerId);
      viewHideTimers.delete(view);
    }
  };
  const scheduleHide = (view) => {
    if (!view) return;
    cancelPendingHide(view);
    const timerId = setTimeout(() => {
      if (!view.classList.contains("active")) {
        view.hidden = true;
      }
      viewHideTimers.delete(view);
    }, SCREEN_FADE_MS + 75);
    viewHideTimers.set(view, timerId);
  };
  const scrollToTop = () => {
    if (typeof window === "undefined") return;
    requestAnimationFrame(() => {
      const scroller = document.scrollingElement || document.documentElement || document.body;
      if (scroller) {
        scroller.scrollTop = 0;
      }
      if (typeof window.scrollTo === "function") {
        window.scrollTo(0, 0);
      }
    });
  };
  const showScreen = (name) => {
    const target = screenViews[name];
    if (!target) return;
    if (target.classList.contains("active")) return;
    Object.entries(screenViews).forEach(([key, view]) => {
      if (!view) return;
      const isActive = key === name;
      if (isActive) {
        cancelPendingHide(view);
        view.hidden = false;
        requestAnimationFrame(() => view.classList.add("active"));
      } else if (view.classList.contains("active")) {
        view.classList.remove("active");
        scheduleHide(view);
      } else {
        view.classList.remove("active");
        view.hidden = true;
      }
    });
    if (name === "suggestions" || name === "home") {
      scrollToTop();
    }
  };
  const showHomeScreen = () => showScreen("home");
  const showSuggestionsScreen = () => showScreen("suggestions");
  backToFormBtn?.addEventListener("click", () => {
    showHomeScreen();
  });
  showHomeScreen();
  const inputField = document.getElementById("inputText");
  const inputLabelEl = document.getElementById("inputLabel");
  const inputCharCounter = document.getElementById("inputCharCount");
  const MIN_SUGGESTIONS = 10;
  const SUGGESTION_STORAGE_KEY = "setel.rewrite.lastSuggestions";
  const toneFallbacks = [
    ["Friendly", "Caring"],
    ["Professional", "Clear"],
    ["Empathetic", "Supportive"],
    ["Persuasive", "Action-focused"],
    ["Playful", "Upbeat"],
    ["Inspirational", "Motivating"],
    ["Neutral", "Informative"],
    ["Urgent", "Time-sensitive"],
    ["Exclusive", "Premium"],
    ["Technical", "Precise"],
  ];
  const MIN_INPUT_HEIGHT = 52;
  const rewriteLabelEl = document.querySelector(".rewrite-label");
  const MODE_REWRITE = "rewrite";
  const generationMode = MODE_REWRITE;
  const MODE_CONFIG = {
    label: "Enter copy",
    placeholder: "Paste copy or select a text layer in Figma",
    buttonLabel: "Rewrite",
    loadingText: "Crafting copy…",
  };
  let rewriteInProgress = false;
  const getModeConfig = () => MODE_CONFIG;
  const updateModeUI = () => {
    const config = getModeConfig();
    if (inputLabelEl) inputLabelEl.textContent = config.label;
    if (inputField && !inputField.value.trim()) {
      inputField.placeholder = config.placeholder;
    }
    if (rewriteLabelEl) rewriteLabelEl.textContent = config.buttonLabel;
    if (!rewriteInProgress && rewriteShimmerText) {
      rewriteShimmerText.textContent = config.loadingText;
    }
  };
  updateModeUI();
  const getModeLoadingText = () => getModeConfig().loadingText;
  const updateRewriteButtonState = () => {
    if (!btnRewrite) return;
    if (rewriteInProgress) {
      btnRewrite.disabled = true;
      return;
    }
    const hasText = Boolean(inputField?.value.trim());
    btnRewrite.disabled = !hasText;
  };
  const setRewriteLoadingState = (isLoading, text) => {
    rewriteInProgress = Boolean(isLoading);
    if (btnRewrite) {
      btnRewrite.classList.toggle("is-loading", rewriteInProgress);
      btnRewrite.setAttribute("aria-busy", rewriteInProgress ? "true" : "false");
    }
    const labelText = typeof text === "string" && text.trim() ? text : getModeLoadingText();
    if (rewriteShimmerText) {
      rewriteShimmerText.textContent = labelText;
    }
    if (!rewriteInProgress) {
      updateModeUI();
    }
    updateRewriteButtonState();
  };
  const autoResizeTextarea = (element, minHeight = MIN_INPUT_HEIGHT) => {
    if (!element) return;
    element.style.height = "auto";
    const nextHeight = Math.max(element.scrollHeight, minHeight);
    element.style.height = `${nextHeight}px`;
  };
  const resizeRewriteInput = () => {
    autoResizeTextarea(inputField, MIN_INPUT_HEIGHT);
  };

  const geminiKeyInput = document.getElementById("apikey");
  const saveKeyBtn = document.getElementById("saveKey");
  const loadKeyBtn = document.getElementById("loadKey");
  const saveStatus = document.getElementById("saveStatus");
  const guidelineStatus = document.getElementById("guidelineStatus");
  const guidelineStatusText = guidelineStatus?.querySelector(".guideline-text");
  const usageContextInput = document.getElementById("usageContextInput");
  const MIN_CONTEXT_HEIGHT = 72;
  const CONTEXT_LINE_HEIGHT = 20;
  const CONTEXT_VERTICAL_PADDING = 24;
  const DEFAULT_CONTEXT_PLACEHOLDER = "";
  const DEFAULT_PLACEHOLDER_LINES = 1;
  let contextPlaceholderSizer = null;
  const updateContextPlaceholder = (text, lineCount = DEFAULT_PLACEHOLDER_LINES) => {
    if (!usageContextInput) return;
    usageContextInput.placeholder = text;
    const totalLines = Math.max(lineCount, DEFAULT_PLACEHOLDER_LINES);
    let minHeight = Math.max(
      MIN_CONTEXT_HEIGHT,
      CONTEXT_VERTICAL_PADDING + totalLines * CONTEXT_LINE_HEIGHT
    );
    if (!contextPlaceholderSizer) {
      contextPlaceholderSizer = document.createElement("div");
      contextPlaceholderSizer.setAttribute("aria-hidden", "true");
      contextPlaceholderSizer.style.position = "absolute";
      contextPlaceholderSizer.style.visibility = "hidden";
      contextPlaceholderSizer.style.whiteSpace = "pre-wrap";
      contextPlaceholderSizer.style.wordBreak = "break-word";
      contextPlaceholderSizer.style.top = "-9999px";
      contextPlaceholderSizer.style.left = "-9999px";
      contextPlaceholderSizer.style.pointerEvents = "none";
      contextPlaceholderSizer.style.boxSizing = "border-box";
      document.body.appendChild(contextPlaceholderSizer);
    }
    const computed = getComputedStyle(usageContextInput);
    contextPlaceholderSizer.style.font = computed.font || "";
    contextPlaceholderSizer.style.lineHeight = computed.lineHeight || "";
    contextPlaceholderSizer.style.padding = computed.padding || "";
    contextPlaceholderSizer.style.width = `${usageContextInput.clientWidth}px`;
    contextPlaceholderSizer.textContent = text;
    const measuredHeight = contextPlaceholderSizer.scrollHeight;
    minHeight = Math.max(minHeight, measuredHeight);
    usageContextInput.style.minHeight = `${minHeight}px`;
    if (!usageContextInput.value.trim().length) {
      usageContextInput.style.height = `${minHeight}px`;
    }
  };
  if (usageContextInput) {
    updateContextPlaceholder(DEFAULT_CONTEXT_PLACEHOLDER, DEFAULT_PLACEHOLDER_LINES);
  }
  const resizeContextInput = () => {
    autoResizeTextarea(usageContextInput, MIN_CONTEXT_HEIGHT);
  };
  let usageContextValue = "";
  const formatCharCount = (count) => `${count} character${count === 1 ? "" : "s"}`;
  const updateInputCharCount = () => {
    if (!inputCharCounter) return;
    const value = inputField?.value || "";
    inputCharCounter.textContent = formatCharCount(value.length);
  };
  const SUGGESTION_INITIAL_DELAY = 320;
  const SUGGESTION_REVEAL_STEP = 180;
  const SKELETON_MIN_DISPLAY_MS = 1100;
  let suggestionRevealTimers = [];
  let skeletonVisibleSince = 0;
  let skeletonActive = false;
  const reducedMotionQuery =
    typeof window !== "undefined" && window.matchMedia
      ? window.matchMedia("(prefers-reduced-motion: reduce)")
      : null;
  const prefersReducedMotion = () => Boolean(reducedMotionQuery?.matches);
  const clearSuggestionRevealTimers = () => {
    suggestionRevealTimers.forEach((timerId) => clearTimeout(timerId));
    suggestionRevealTimers = [];
    skeletonVisibleSince = 0;
    skeletonActive = false;
  };
  const resetSuggestionCardInteractivity = (card) => {
    if (!card) return;
    card.classList.remove("is-interactive", "revealed");
    card.removeAttribute("role");
    card.removeAttribute("tabindex");
    card.removeAttribute("data-text");
  };
  const createSkeletonCardElement = () => {
    const card = document.createElement("article");
    card.className = "suggestion-card skeleton";
    resetSuggestionCardInteractivity(card);
    card.innerHTML = `
      <div class="skeleton-line skeleton-block long"></div>
      <div class="skeleton-line skeleton-block"></div>
      <div class="skeleton-line skeleton-block short"></div>
      <div class="skeleton-meta">
        <span class="skeleton-pill skeleton-block"></span>
        <span class="skeleton-pill skeleton-block short"></span>
        <span class="skeleton-pill skeleton-block"></span>
      </div>
    `;
    return card;
  };
  const renderSkeletonPlaceholders = (count = MIN_SUGGESTIONS) => {
    if (!suggestionBody) return { list: null, cards: [] };
    clearSuggestionRevealTimers();
    suggestionBody.className = "suggestion-body";
    suggestionBody.innerHTML = "";
    const list = document.createElement("div");
    list.className = "suggestions-list is-loading";
    suggestionBody.appendChild(list);
    const total = Math.max(1, Number(count) || 0);
    const cards = [];
    for (let i = 0; i < total; i += 1) {
      const card = createSkeletonCardElement();
      list.appendChild(card);
      cards.push(card);
    }
    skeletonVisibleSince =
      typeof performance !== "undefined" && performance.now ? performance.now() : Date.now();
    skeletonActive = true;
    return { list, cards };
  };
  const revealCardContent = (card, item) => {
    if (!card) return;
    card.classList.remove("skeleton");
    card.dataset.text = item.text;
    card.innerHTML = `
      <p>${item.text}</p>
      <div class="suggestion-meta">
        <span>${item.tones.join(", ")}</span>
        <span class="suggestion-dot" aria-hidden="true">·</span>
        <span class="suggestion-char">${formatCharCount(item.charCount ?? item.text.length)}</span>
      </div>
    `;
    card.setAttribute("role", "button");
    card.tabIndex = 0;
    card.classList.add("is-interactive");
    card.addEventListener("click", handleSuggestionCardClick);
    card.addEventListener("keydown", handleSuggestionCardKeydown);
    card.classList.add("revealing");
    requestAnimationFrame(() => {
      card.classList.remove("revealing");
      card.classList.add("revealed");
    });
  };
  const scheduleSuggestionReveal = (cards, items, list) => {
    if (!cards.length || !items.length) return;
    const baseDelay = prefersReducedMotion() ? 0 : SUGGESTION_INITIAL_DELAY;
    const stepDelay = prefersReducedMotion() ? 0 : SUGGESTION_REVEAL_STEP;
    cards.forEach((card, idx) => {
      const now = typeof performance !== "undefined" && performance.now ? performance.now() : Date.now();
      const elapsed = Math.max(0, now - skeletonVisibleSince);
      const minVisibleOffset =
        skeletonActive && !prefersReducedMotion()
          ? Math.max(SKELETON_MIN_DISPLAY_MS - elapsed, 0)
          : 0;
      const timer = setTimeout(() => {
        revealCardContent(card, items[idx]);
        if (idx === cards.length - 1 && list) {
          list.classList.remove("is-loading");
          skeletonActive = false;
          skeletonVisibleSince = 0;
        }
      }, baseDelay + idx * stepDelay + minVisibleOffset);
      suggestionRevealTimers.push(timer);
    });
  };

  const fallbackGuideline = Object.freeze({
    name: "Warm lower-case headings",
    instructions:
      "Write 2-6 word lower-case headings with a warm, appreciative, enthusiastic tone. Keep copy mobile friendly and avoid emojis unless explicitly requested.",
    examples: [
      "thanks for being here",
      "we love having you",
      "you're in great company",
    ],
  });

  const guidelineMeta = {
    rewriteOverview: "",
    rewriteRequirements: [],
  };
  // const LENGTH_PRESETS = [
  //   { label: "Short", value: 32 },
  //   { label: "Medium", value: 64 },
  //   { label: "Long", value: 106 },
  // ];

  const shortenHelperText = (text) => {
    const clean = String(text || "").trim();
    if (!clean) return "";
    const withoutLead = clean
      .replace(
        /^(Use|Keep|Explain|Provide|Offer|Make|Add|Focus on|Highlight|Remember|Ensure|Avoid|Encourage|Maintain|Share|Deliver|Emphasize|Support)\b[\s,:-]*/i,
        ""
      )
      .trim();
    const tightened = withoutLead
      .replace(/\b(make sure to|be sure to|try to|aim to|you should|you must)\b/gi, "")
      .replace(/\b(please|really|just)\b/gi, "")
      .replace(/\b(your|their)\s+(users?|audience|customers?)\b/gi, "$2")
      .replace(/\s{2,}/g, " ")
      .trim();
    const candidate = tightened || withoutLead || clean;
    return candidate.replace(/[.:;]+$/, "").trim();
  };

  const updateContextHints = () => {
    if (!usageContextInput) return;
    const helperLines = (guidelineMeta.rewriteRequirements || [])
      .map((req) => shortenHelperText(req))
      .filter(Boolean)
      .slice(0, 3);
    if (!helperLines.length) {
      updateContextPlaceholder(DEFAULT_CONTEXT_PLACEHOLDER, DEFAULT_PLACEHOLDER_LINES);
      return;
    }
    updateContextPlaceholder(helperLines.join("\n"), helperLines.length);
  };

  const applyGuidelineMeta = (guide) => {
    const rewritePrompt = guide?.rewritePrompt || {};
    guidelineMeta.rewriteOverview =
      typeof rewritePrompt.overview === "string" ? rewritePrompt.overview.trim() : "";
    guidelineMeta.rewriteRequirements = Array.isArray(rewritePrompt.requirements)
      ? rewritePrompt.requirements
          .map((item) => (typeof item === "string" ? item.trim() : ""))
          .filter(Boolean)
      : [];
    updateContextHints();
  };

  window.addEventListener("resize", () => {
    if (usageContextInput && !usageContextInput.value.trim().length) {
      updateContextHints();
    }
  });

  const setGuidelineIndicator = (state, text) => {
    if (!guidelineStatus || !guidelineStatusText) return;
    guidelineStatus.classList.remove("loaded", "fallback", "error");
    guidelineStatus.classList.add(state);
    guidelineStatusText.textContent = text;
  };

  let guidelineReference = null;
  const getGuidelinePayload = () => {
    if (guidelineReference) return guidelineReference;
    setGuidelineIndicator("fallback", "Using fallback style guide.");
    return fallbackGuideline;
  };
  const buildGuidelinePayload = () => {
    const base = getGuidelinePayload();
    const payload = base && typeof base === "object" ? { ...base } : {};
    delete payload.tonePreference;
    delete payload.styleFilters;
    if (usageContextValue) {
      payload.usageContext = usageContextValue;
    } else {
      delete payload.usageContext;
    }
    return payload;
  };
  setGuidelineIndicator("fallback", "Loading style guide…");

  const resolveTargetOrigin = () => {
    try {
      const ref = document.referrer;
      if (ref && ref !== "null") {
        return new URL(ref).origin;
      }
    } catch (err) {
      console.warn("Could not parse parent origin:", err);
    }
    return "https://www.figma.com";
  };

  const targetOrigin = resolveTargetOrigin();

  const postToPlugin = (pluginMessage) => {
    if (!window.parent || window.parent === window) {
      console.warn("Figma host unavailable; skipping postMessage", pluginMessage);
      return;
    }
    window.parent.postMessage({ pluginMessage }, targetOrigin);
  };
  const applySuggestionText = (text) => {
    if (typeof text !== "string" || !text.trim()) return;
    if (inputField) {
      inputField.value = text;
      inputField.dispatchEvent(new Event("input"));
    }
    postToPlugin({ type: "apply-text", text });
  };
  const activateSuggestionCard = (target) => {
    const card = target instanceof HTMLElement ? target : null;
    if (!card || card.classList.contains("skeleton")) return;
    const text = card.getAttribute("data-text") || "";
    if (!text.trim()) return;
    applySuggestionText(text);
  };
  const handleSuggestionCardClick = (event) => {
    if (!event?.currentTarget) return;
    event.preventDefault();
    activateSuggestionCard(event.currentTarget);
  };
  const handleSuggestionCardKeydown = (event) => {
    if (!event?.currentTarget) return;
    const key = event.key;
    if (key === "Enter" || key === " ") {
      event.preventDefault();
      activateSuggestionCard(event.currentTarget);
    }
  };

  const renderEmptyState = () => {
    if (restoreSuggestionsFromStorage()) {
      return;
    }
    clearSuggestionRevealTimers();
    suggestionBody.className = "suggestion-body centered";
    suggestionBody.innerHTML = `
      <div class="empty-arrow">↑</div>
      <p>Paste copy to rewrite, then click the button for fresh suggestions.</p>
    `;
  };

  const renderLoading = (text, skeletonCount = MIN_SUGGESTIONS) => {
    showSuggestionsScreen();
    renderSkeletonPlaceholders(skeletonCount);
    const labelText = typeof text === "string" && text.trim() ? text : getModeLoadingText();
    if (rewriteShimmerText) {
      rewriteShimmerText.textContent = labelText;
    }
  };

  const renderStatus = (text) => {
    clearSuggestionRevealTimers();
    suggestionBody.className = "suggestion-body centered";
    suggestionBody.innerHTML = `<p>${text}</p>`;
  };

  const renderError = (text) => {
    clearSuggestionRevealTimers();
    suggestionBody.className = "suggestion-body centered error";
    suggestionBody.innerHTML = `<p>${text || "Something went wrong. Try again in a bit."}</p>`;
  };

  const renderSuggestions = (items, options = {}) => {
    if (!items.length) {
      renderStatus("No response.");
      return;
    }

    const noticeText =
      typeof options.noticeText === "string" && options.noticeText.trim() ? options.noticeText.trim() : "";
    const { list, cards } = renderSkeletonPlaceholders(items.length);
    if (!cards.length || !list) {
      skeletonActive = false;
      skeletonVisibleSince = 0;
      const fallbackCards = items
        .map(
          (item) => `
        <article class="suggestion-card">
          <p>${item.text}</p>
          <div class="suggestion-meta">
            <span>${item.tones.join(", ")}</span>
            <span class="suggestion-dot" aria-hidden="true">·</span>
            <span class="suggestion-char">${formatCharCount(item.charCount ?? item.text.length)}</span>
          </div>
        </article>`
        )
        .join("");
      suggestionBody.className = "suggestion-body";
      const noticeMarkup = noticeText ? `<div class="suggestion-note">${noticeText}</div>` : "";
      suggestionBody.innerHTML = `${noticeMarkup}<div class="suggestions-list">${fallbackCards}</div>`;
      return;
    }
    if (noticeText) {
      const noticeEl = document.createElement("div");
      noticeEl.className = "suggestion-note";
      noticeEl.textContent = noticeText;
      suggestionBody.insertBefore(noticeEl, list);
    }
    scheduleSuggestionReveal(cards, items, list);
  };

  const saveSuggestionsSnapshot = (payload) => {
    try {
      if (!window.localStorage) return;
      const serialized = JSON.stringify(payload);
      window.localStorage.setItem(SUGGESTION_STORAGE_KEY, serialized);
    } catch (err) {
      console.warn("Unable to save suggestions to storage:", err);
    }
  };

  const loadSuggestionsSnapshot = () => {
    try {
      if (!window.localStorage) return null;
      const raw = window.localStorage.getItem(SUGGESTION_STORAGE_KEY);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!parsed || !Array.isArray(parsed.suggestions) || !parsed.suggestions.length) {
        return null;
      }
      return parsed;
    } catch (err) {
      console.warn("Unable to read suggestions from storage:", err);
      return null;
    }
  };

  const restoreSuggestionsFromStorage = () => {
    const snapshot = loadSuggestionsSnapshot();
    if (!snapshot) return false;
    const { suggestions, noticeText } = snapshot;
    if (!Array.isArray(suggestions) || !suggestions.length) {
      return false;
    }
    showSuggestionsScreen();
    renderSuggestions(suggestions, noticeText ? { noticeText } : undefined);
    return true;
  };

  const stripFormatting = (line) =>
    line
      .replace(/[*_`]/g, "")
      .replace(/^\d+[\.)-]*\s*/, "")
      .replace(/^[-•*]+\s*/, "")
      .replace(/\s+/g, " ")
      .trim();
  const stripTrailingCharCount = (text) => {
    if (!text) return text;
    return text.replace(/\s*\(\s*~?\d+\s*(?:char(?:s)?|character(?:s)?)\s*\)\s*$/i, "").trim();
  };

  const looksLikeMeta = (line) => {
    const lower = line.toLowerCase();
    const normalized = lower.replace(/[’]/g, "'");
    if (!lower) return true;
    if (lower.length <= 2) return true;
    const metaPrefixes = [
      "here are",
      "here's",
      "these are",
      "please note",
      "okay, i'm",
      "alright, i'm",
      "i'm ready",
      "let me",
      "i will",
      "i can",
      "remember:",
      "for reference",
      "guideline:",
      "dialog:",
      "instruction:",
    ];
    if (metaPrefixes.some((p) => lower.startsWith(p))) return true;
    if (/^option\s*\d+/i.test(lower)) return true;
    if (lower.startsWith("option ") || lower.startsWith("option:")) return true;
    if (lower.includes("option ") && lower.endsWith(":")) return true;
    if (lower.includes("dialog") || lower.includes("instruction")) return true;
    if (lower.endsWith(":") && (lower.includes("requirement") || lower.includes("suggestion"))) return true;
    if (lower.includes("i've provided") || lower.includes("i have provided")) return true;
    if (lower.includes("below are") || lower.includes("as requested")) return true;
    const conversationalPatterns = [
      /we understand\b/,
      /we know\b/,
      /we're here\b/,
      /it's great you're\b/,
      /it is great you're\b/,
      /let's see\b/,
      /let's find\b/,
      /let's check\b/,
      /let's explore\b/,
      /let's walk\b/,
      /let's take\b/,
      /let's talk\b/,
      /let's get you\b/,
    ];
    if (conversationalPatterns.some((pattern) => pattern.test(normalized))) return true;
    return false;
  };

  const expandNumberedItems = (text) => {
    if (!/\d+[\.)-]/.test(text)) return null;
    const segments = text
      .split(/\d+[\.)-]\s*/g)
      .map((segment) => segment.trim())
      .filter(Boolean);
    return segments.length >= 2 ? segments : null;
  };

  const classifyLength = (count) => {
    if (count <= 45) return "Short";
    if (count <= 80) return "Medium";
    return "Long";
  };
  const buildSuggestions = (raw) => {
    if (!raw) return [];

    const expandedRaw = raw.replace(/(\d+[\.)-])/g, "\n$1");
    let blocks = expandedRaw.split(/\n{2,}/);
    if (blocks.length === 1) {
      blocks = expandedRaw.split(/\n+/);
    }

    const normalized = blocks
      .map((block) => stripFormatting(block))
      .filter(Boolean)
      .filter((block) => !looksLikeMeta(block));

    const flattened = normalized.flatMap((text) => {
      const expanded = expandNumberedItems(text);
      return expanded && expanded.length ? expanded : [text];
    });

    const unique = [];
    const seen = new Set();
    flattened.forEach((text) => {
      const clean = stripTrailingCharCount(stripFormatting(text));
      if (!clean) return;
      const key = clean.toLowerCase();
      if (!seen.has(key)) {
        seen.add(key);
        unique.push(clean);
      }
    });

    const enriched = unique.map((text) => {
      const charCount = text.length;
      return {
        text,
        charCount,
        lengthLabel: classifyLength(charCount),
      };
    });

    const bucketOrder = ["Short", "Medium", "Long"];
    const bucketTargets = {
      Short: 3,
      Medium: 3,
      Long: 3,
    };
    const buckets = {
      Short: [],
      Medium: [],
      Long: [],
    };
    enriched.forEach((item) => {
      if (buckets[item.lengthLabel]) {
        buckets[item.lengthLabel].push(item);
      } else {
        buckets.Long.push(item);
      }
    });

    const selected = [];
    const usedKeys = new Set();

    bucketOrder.forEach((bucket) => {
      const bucketItems = buckets[bucket] || [];
      const target = bucketTargets[bucket] || 0;
      let count = 0;
      for (const item of bucketItems) {
        const key = item.text.toLowerCase();
        if (usedKeys.has(key)) continue;
        selected.push(item);
        usedKeys.add(key);
        count += 1;
        if (count >= target) break;
      }
    });

    if (selected.length < MIN_SUGGESTIONS) {
      enriched.forEach((item) => {
        if (selected.length >= MIN_SUGGESTIONS) return;
        const key = item.text.toLowerCase();
        if (!usedKeys.has(key)) {
          selected.push(item);
          usedKeys.add(key);
        }
      });
    }

    return selected.slice(0, MIN_SUGGESTIONS).map((item, idx) => ({
      ...item,
      score: Math.max(80, 95 - idx * 2),
      tones: toneFallbacks[idx % toneFallbacks.length],
    }));
  };

  const applySelectionText = (text) => {
    if (!text) return;
    inputField.value = text;
    inputField.dispatchEvent(new Event("input"));
  };

  updateContextHints();

  usageContextInput?.addEventListener("input", () => {
    usageContextValue = usageContextInput.value.trim();
    resizeContextInput();
    updateContextHints();
  });

  btnRewrite.onclick = async () => {
    const text = inputField.value.trim();
    if (!text) {
      alert("Please enter some text.");
      return;
    }
    const mode = generationMode;
    const guidelinePayload = buildGuidelinePayload();
    setRewriteLoadingState(true);
    renderLoading();

    const key = geminiKeyInput ? geminiKeyInput.value.trim() : "";
    if (!key) {
      postToPlugin({ type: "load-key" });
      renderLoading("Loading saved key…");
      window.__pendingText = text;
      window.__pendingGuideline = guidelinePayload;
      window.__pendingMode = mode;
      return;
    }

    delete window.__pendingGuideline;
    delete window.__pendingMode;
    postToPlugin({ type: "rewrite", key, text, guideline: guidelinePayload, mode });
  };

  inputField.addEventListener("input", () => {
    const hasText = Boolean(inputField.value.trim());
    updateRewriteButtonState();
    updateInputCharCount();
    resizeRewriteInput();
    if (!hasText && !window.__pendingText) {
      renderEmptyState();
    }
  });

  // settings save/load
  saveKeyBtn.onclick = () => {
    const key = geminiKeyInput.value.trim();
    postToPlugin({ type: "save-key", key });
    saveStatus.textContent = "Saving…";
  };
  loadKeyBtn.onclick = () => {
    postToPlugin({ type: "load-key" });
    saveStatus.textContent = "Loading…";
  };

  // messages from main
  onmessage = (event) => {
    const msg = event.data.pluginMessage;

    if (msg?.type === "guideline-default") {
      if (msg.error) {
        guidelineReference = null;
        setGuidelineIndicator("error", "Couldn't load style guide. Using fallback.");
        guidelineMeta.rewriteOverview = "";
        guidelineMeta.rewriteRequirements = [];
        updateContextHints();
      } else if (msg.guideline) {
        guidelineReference = msg.guideline;
        setGuidelineIndicator("loaded", "Using structured style guide.");
        applyGuidelineMeta(msg.guideline);
      } else {
        guidelineReference = null;
        setGuidelineIndicator("fallback", "Using fallback style guide.");
        guidelineMeta.rewriteOverview = "";
        guidelineMeta.rewriteRequirements = [];
        updateContextHints();
      }
      return;
    }

    if (msg?.type === "key-saved") {
      saveStatus.textContent = msg.error ? ("Save failed: " + msg.error) : "Key saved.";
      if (!msg.error && typeof msg.key === "string") {
        geminiKeyInput.value = msg.key;
      }
      return;
    }
    if (msg?.type === "key-loaded") {
      if (msg.error) {
        saveStatus.textContent = "Load failed: " + msg.error;
        setRewriteLoadingState(false);
        if (window.__pendingText) {
          showSuggestionsScreen();
          renderStatus("Couldn't load your API key. Add it in Settings to try again.");
          delete window.__pendingText;
          delete window.__pendingGuideline;
          activate("settings");
        }
        return;
      }

      const loadedKeyRaw = typeof msg.key === "string" ? msg.key : "";
      const loadedKey = loadedKeyRaw.trim();

      geminiKeyInput.value = loadedKeyRaw;
      saveStatus.textContent = loadedKey ? "Key loaded." : "No key saved yet.";

      if (window.__pendingText) {
        if (loadedKey) {
          const text = window.__pendingText;
          const guide = window.__pendingGuideline || buildGuidelinePayload();
          const pendingMode = window.__pendingMode || generationMode;
          delete window.__pendingText;
          delete window.__pendingGuideline;
          delete window.__pendingMode;
          postToPlugin({ type: "rewrite", key: loadedKey, text, guideline: guide, mode: pendingMode });
          setRewriteLoadingState(true);
          renderLoading();
        } else {
          setRewriteLoadingState(false);
          showSuggestionsScreen();
          renderStatus("Add your Gemini API key in Settings to generate copy suggestions.");
          delete window.__pendingText;
          delete window.__pendingGuideline;
          delete window.__pendingMode;
          activate("settings");
        }
      }
      return;
    }
    if (msg?.type === "error") {
      const errText =
        typeof msg.error === "string"
          ? msg.error
          : msg && msg.error && msg.error.message
          ? String(msg.error.message)
          : "Unknown error.";
      console.error("Gemini rewrite error:", msg.error);
      setRewriteLoadingState(false);
      activate("rewrite");
      showSuggestionsScreen();
      renderError("Generation failed: " + errText);
      return;
    }
    if (msg?.type === "selection-text") {
      if (typeof msg.text === "string" && msg.text.length) {
        applySelectionText(msg.text);
      }
      return;
    }
    if (msg?.type === "rewrite-done") {
      const output = typeof msg.output === "string" ? msg.output.trim() : "";
      setRewriteLoadingState(false);
      showSuggestionsScreen();
      if (msg.error) {
        renderError(output);
      } else {
        const suggestions = buildSuggestions(output);
        if (suggestions.length) {
          const noticeText =
            suggestions.length < MIN_SUGGESTIONS
              ? `Only ${suggestions.length}/${MIN_SUGGESTIONS} suggestions returned. Showing available results.`
              : "";
          renderSuggestions(suggestions, noticeText ? { noticeText } : undefined);
          saveSuggestionsSnapshot({
            suggestions,
            noticeText,
            sourceText: inputField?.value?.trim() || "",
            usageContext: usageContextValue,
            storedAt: Date.now(),
          });
        } else {
          renderError(output || "No response.");
        }
      }
      activate("rewrite");
      return;
    }
  };

  // auto-load key when opening settings
  tabs.settings.tab.addEventListener("click", ()=> {
    postToPlugin({ type: "load-key" });
    saveStatus.textContent = "Loading…";
  });

  updateInputCharCount();
  resizeRewriteInput();
  resizeContextInput();
  renderEmptyState();
  postToPlugin({ type: "request-guideline" });
</script>
